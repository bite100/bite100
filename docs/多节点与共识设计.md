# 多节点与共识设计文档

> 版本：v1.0  
> 更新日期：2025-02-08

---

## 一、概述

本文档描述 P2P DEX 的多节点撮合与共识机制，包括两种扩展方案：

- **方案 B（分片按交易对）**：按交易对分片，不同交易对由不同撮合节点负责
- **方案 C（多节点共识）**：多个撮合节点对同一订单簿做共识（如 BFT），输出一致撮合结果

当前实现为**方案 A（单主撮合）**，所有订单路由到单一主撮合节点。

---

## 二、方案 B：分片按交易对

### 2.1 设计目标

- **扩展性**：不同交易对由不同撮合节点处理，避免单点瓶颈
- **负载均衡**：按交易对流量分配节点资源
- **故障隔离**：单个交易对的故障不影响其他交易对

### 2.2 架构设计

```
┌─────────────────────────────────────────────────────────┐
│                    订单路由层（Router）                    │
│  根据 pair 哈希选择目标撮合节点，转发订单到对应节点          │
└─────────────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
   ┌────▼────┐ ┌────▼────┐ ┌────▼────┐
   │撮合节点1 │ │撮合节点2 │ │撮合节点3 │
   │TKA/TKB  │ │TKC/TKD  │ │TKE/TKF  │
   └─────────┘ └─────────┘ └─────────┘
```

### 2.3 核心组件

#### 2.3.1 节点注册与发现

**节点注册**：
- 撮合节点启动时，通过 Gossip 广播自己的 `PeerID` 和负责的交易对列表
- 使用 Topic `/p2p-exchange/match/register` 广播注册信息

**节点发现**：
- 路由节点订阅 `/p2p-exchange/match/register`，维护 `pair -> []PeerID` 映射
- 定期刷新节点列表，移除离线节点

**数据结构**：
```go
type MatchNodeInfo struct {
    PeerID    string   // libp2p PeerID
    Pairs     []string // 负责的交易对列表
    Capacity  int      // 当前负载（订单数）
    UpdatedAt int64    // 最后更新时间
}
```

#### 2.3.2 订单路由

**路由算法**：
1. 计算 `pair` 的哈希值：`hash(pair) % len(nodes)`
2. 选择对应索引的节点（支持多副本时，可选择负载最低的节点）
3. 如果目标节点离线，选择下一个可用节点

**路由表**：
```go
type Router struct {
    pairToNodes map[string][]string // pair -> []PeerID
    nodeInfo    map[string]*MatchNodeInfo // PeerID -> 节点信息
    mu          sync.RWMutex
}
```

**路由流程**：
```
收到订单 → 解析 pair → 查询路由表 → 选择目标节点 → 转发订单
```

#### 2.3.3 订单转发

**转发协议**：
- 使用 Gossip Topic `/p2p-exchange/match/order/{pair}` 或直接 P2P 消息
- 订单格式与现有 `/order/new` 一致
- 目标节点收到后，执行撮合并广播成交

**转发消息格式**：
```json
{
  "type": "route_order",
  "targetPeerID": "12D3KooW...",
  "order": { ... }
}
```

### 2.4 实现细节

#### 2.4.1 节点注册

**注册消息**：
```go
type MatchNodeRegistration struct {
    PeerID   string   `json:"peerId"`
    Pairs    []string `json:"pairs"`
    Capacity int      `json:"capacity"`
    Timestamp int64   `json:"timestamp"`
}
```

**注册流程**：
1. 节点启动时，读取配置中的 `match.pairs` 列表
2. 构造注册消息，通过 Gossip 广播
3. 定期（如每 30 秒）重新广播，更新 `Capacity`

#### 2.4.2 路由模块

**路由接口**：
```go
type Router interface {
    // 注册节点
    RegisterNode(peerID string, pairs []string, capacity int)
    
    // 选择目标节点
    SelectNode(pair string) (string, error)
    
    // 更新节点状态
    UpdateNodeCapacity(peerID string, capacity int)
    
    // 移除离线节点
    RemoveNode(peerID string)
}
```

**路由实现**：
```go
func (r *Router) SelectNode(pair string) (string, error) {
    r.mu.RLock()
    defer r.mu.RUnlock()
    
    nodes, ok := r.pairToNodes[pair]
    if !ok || len(nodes) == 0 {
        // 如果没有专门节点，使用哈希选择
        return r.selectByHash(pair)
    }
    
    // 选择负载最低的节点
    return r.selectLowestLoad(nodes)
}
```

#### 2.4.3 订单转发

**转发逻辑**：
```go
func (r *Router) RouteOrder(order *storage.Order) error {
    targetPeerID, err := r.SelectNode(order.Pair)
    if err != nil {
        return err
    }
    
    // 如果目标节点是本地节点，直接处理
    if targetPeerID == r.localPeerID {
        return r.localEngine.AddOrder(order)
    }
    
    // 否则转发到目标节点
    return r.forwardToNode(targetPeerID, order)
}
```

### 2.5 配置

**节点配置**：
```yaml
match:
  mode: "sharding"  # sharding | single | consensus
  pairs:
    - "TKA/TKB"
    - "TKC/TKD"
  router:
    enable: true
    refresh_interval: 30s  # 节点列表刷新间隔
```

### 2.6 优势与限制

**优势**：
- ✅ 水平扩展：新增交易对只需新增节点
- ✅ 负载分散：不同交易对互不影响
- ✅ 故障隔离：单个交易对故障不影响其他

**限制**：
- ⚠️ 需要路由层：增加系统复杂度
- ⚠️ 跨交易对订单：需要特殊处理（如跨交易对套利）
- ⚠️ 节点动态变化：需要处理节点上下线

---

## 三、方案 C：多节点共识

### 3.1 设计目标

- **一致性**：多个撮合节点对同一订单簿达成一致
- **安全性**：即使部分节点故障或作恶，仍能输出正确结果
- **可验证性**：所有节点输出相同的撮合结果

### 3.2 架构设计

```
┌─────────────────────────────────────────────────────────┐
│              共识层（Consensus Layer）                    │
│  多个撮合节点对订单簿状态达成一致，输出相同撮合结果          │
└─────────────────────────────────────────────────────────┘
                    │
        ┌───────────┼───────────┐
        │           │           │
   ┌────▼────┐ ┌────▼────┐ ┌────▼────┐
   │撮合节点1 │ │撮合节点2 │ │撮合节点3 │
   │订单簿副本 │ │订单簿副本 │ │订单簿副本 │
   └─────────┘ └─────────┘ └─────────┘
```

### 3.3 共识协议

#### 3.3.1 BFT 共识流程

**阶段 1：提案（Propose）**
- 主节点（Leader）收到订单后，构造撮合提案
- 提案包含：订单信息、撮合结果、订单簿状态哈希

**阶段 2：预投票（PreVote）**
- 所有节点验证提案（签名、余额、撮合逻辑）
- 如果验证通过，广播 PreVote

**阶段 3：预提交（PreCommit）**
- 节点收到 2f+1 个 PreVote 后，广播 PreCommit
- f 为最大容错节点数（总节点数 n，f = (n-1)/3）

**阶段 4：提交（Commit）**
- 节点收到 2f+1 个 PreCommit 后，提交撮合结果
- 广播成交并更新本地订单簿

#### 3.3.2 提案格式

```go
type MatchProposal struct {
    ProposalID   string          // 提案 ID（订单 ID + 时间戳）
    Order        *storage.Order  // 待撮合订单
    Trades       []*storage.Trade // 撮合结果
    OrderbookHash string         // 订单簿状态哈希
    Timestamp    int64           // 提案时间
    LeaderID     string          // 主节点 PeerID
    Signature    string          // 主节点签名
}
```

#### 3.3.3 投票格式

```go
type ConsensusVote struct {
    ProposalID  string // 提案 ID
    VoterID     string // 投票节点 PeerID
    VoteType    string // "prevote" | "precommit"
    Result      bool   // true=通过, false=拒绝
    Reason      string // 拒绝原因（可选）
    Signature   string // 投票节点签名
}
```

### 3.4 实现细节

#### 3.4.1 共识引擎

**共识接口**：
```go
type ConsensusEngine interface {
    // 启动共识
    Start() error
    
    // 处理新订单（主节点）
    ProposeMatch(order *storage.Order) error
    
    // 处理提案（从节点）
    HandleProposal(proposal *MatchProposal) error
    
    // 处理投票
    HandleVote(vote *ConsensusVote) error
    
    // 获取当前 Leader
    GetLeader() string
}
```

#### 3.4.2 Leader 选举

**选举算法**：
- 使用 Raft 风格的 Leader 选举
- Leader 任期（Term）基于区块高度或时间窗口
- 节点离线时自动重新选举

**选举消息**：
```go
type LeaderElection struct {
    Term      int64  // 任期
    Candidate string // 候选节点 PeerID
    Votes     []string // 投票节点列表
}
```

#### 3.4.3 订单簿同步

**同步机制**：
- 每个共识周期开始时，同步订单簿快照
- 使用 Merkle Tree 验证订单簿一致性
- 不一致时触发重新同步

**同步消息**：
```go
type OrderbookSync struct {
    Pair         string   // 交易对
    SnapshotHash string   // 快照哈希
    MerkleRoot   string   // Merkle 根
    Timestamp    int64    // 快照时间
}
```

### 3.5 配置

**节点配置**：
```yaml
match:
  mode: "consensus"  # sharding | single | consensus
  consensus:
    type: "bft"  # bft | raft
    nodes:
      - "12D3KooW..."
      - "12D3KooX..."
      - "12D3KooY..."
    timeout:
      propose: 2s    # 提案超时
      vote: 1s       # 投票超时
      commit: 1s     # 提交超时
```

### 3.6 优势与限制

**优势**：
- ✅ 强一致性：所有节点输出相同结果
- ✅ 容错性：可容忍 f 个节点故障
- ✅ 安全性：防止单点作恶

**限制**：
- ⚠️ 延迟较高：需要多轮通信
- ⚠️ 复杂度高：实现和维护成本高
- ⚠️ 吞吐量限制：共识开销影响性能

---

## 四、方案对比

| 特性 | 方案 A（单主） | 方案 B（分片） | 方案 C（共识） |
|------|--------------|--------------|--------------|
| **扩展性** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ |
| **一致性** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **延迟** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐ |
| **复杂度** | ⭐⭐⭐⭐⭐ | ⭐⭐⭐ | ⭐ |
| **容错性** | ⭐⭐ | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ |
| **适用场景** | 小规模 | 大规模多交易对 | 高安全需求 |

---

## 五、实施建议

### 5.1 阶段 1：实现方案 B（分片）

**优先级**：高  
**原因**：扩展性好，实现相对简单，适合当前需求

**实施步骤**：
1. 实现节点注册与发现
2. 实现路由模块
3. 实现订单转发
4. 测试与优化

### 5.2 阶段 2：实现方案 C（共识）

**优先级**：中  
**原因**：复杂度高，适合高安全需求场景

**实施步骤**：
1. 实现 BFT 共识协议
2. 实现 Leader 选举
3. 实现订单簿同步
4. 测试与优化

### 5.3 混合方案

**建议**：可以同时支持两种方案
- 小交易对：使用方案 B（分片）
- 大交易对：使用方案 C（共识）

---

## 六、相关文档

- [Phase3-设计文档](./Phase3-设计文档.md)
- [技术架构说明](./技术架构说明.md)
- [节点部署](./节点部署.md)

---

*本文档描述多节点撮合与共识的设计方案，可根据实际需求选择合适的方案。*
