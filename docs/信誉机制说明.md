# 信誉机制说明

> 版本：v1.0  
> 更新日期：2025-02-08  
> 说明：无需准入但奖励仅给高信誉节点的实现

---

## 一、概述

P2P DEX 采用**完全开放但按信誉分分配奖励**的机制：
- **完全开放**：**中继/撮合节点入网无任何条件**，无需白名单、无需质押、无需邀请，任何节点都可以自由加入网络
- **按信誉分分配**：奖励按照（贡献分 × 信誉分数/10000）进行分配，信誉分数越高，获得的奖励越多

这既保证了网络的完全开放性，又通过经济激励鼓励节点提供高质量服务。信誉分数高的节点会获得更多的奖励份额，形成正向激励循环。

**重要原则**：
- ✅ 节点可以随时加入，无需任何审批或条件
- ✅ 节点可以随时退出，无需任何手续
- ✅ 奖励分配基于信誉分数，而非准入条件

**分配模式**：
- **模式一**：仅用信誉阈值作为门槛（`useReputationWeighting = false`）
- **模式二**：按信誉分加权分配（`useReputationWeighting = true`）⭐ **推荐**

详细示例见 [信誉分配示例](./信誉分配示例.md)。

---

## 二、信誉分数计算

### 2.1 计算因素

节点信誉分数（0-10000，10000 为最高）基于以下因素：

1. **转发量**（最多 5000 分）
   - 基于节点转发的字节数
   - 1TB 转发量 = 5000 分

2. **违规惩罚**（扣分）
   - 每次违规扣 500 分
   - 违规包括：超限被丢弃、恶意行为等

3. **在线时长**（最多 3000 分）
   - 基于节点活跃时长
   - 30 天活跃 = 3000 分

4. **转发/违规比例**（最多 2000 分）
   - 无违规且有转发量：2000 分
   - 转发量是违规次数的 1000 倍以上：2000 分
   - 其他情况按比例计算

### 2.2 计算公式

```go
// 基础分数（转发量 - 违规惩罚）
baseScore = min(bytesRelayed / 1TB * 5000, 5000) - violations * 500
if baseScore < 0 { baseScore = 0 }

// 在线时长奖励
uptimeScore = min(activeDays / 30 * 3000, 3000)

// 比例奖励
ratioScore = calculateRatioScore(bytesRelayed, violations)

// 总分
totalScore = min(baseScore + uptimeScore + ratioScore, 10000)
```

---

## 三、合约实现

### 3.1 ContributorReward 合约

**新增状态变量**：
- `useReputationWeighting`：是否启用按信誉分加权分配（true：按信誉分分配；false：仅用阈值作为门槛）
- `reputationThreshold`：信誉阈值（0 表示不启用）
- `reputationScore[address]`：每个节点的信誉分数（0-10000）
- `periodTotalWeightedScore[periodId]`：每个周期的总加权贡献分（贡献分 * 信誉分数/10000 的总和）

**新增方法**：
- `setReputationScore(address, uint256)`：设置单个节点信誉（仅 owner）
- `setReputationScores(address[], uint256[])`：批量设置信誉（仅 owner）
- `setReputationThreshold(uint256)`：设置信誉阈值（仅 governance）
- `setReputationWeighting(bool)`：启用/禁用按信誉分加权分配（仅 governance）
- `updateReputationAndRecalculateWeightedScore(address, uint256, string[])`：更新信誉并重新计算加权贡献分（仅 owner）
- `isReputationQualified(address)`：查询节点是否满足信誉要求

**claimReward 修改**：
- 如果 `reputationThreshold > 0`，检查 `reputationScore[msg.sender] >= reputationThreshold`
- 如果 `useReputationWeighting = true`，按加权贡献分分配：
  - 我的加权贡献分 = 贡献分 * (信誉分数 / 10000)
  - 奖励 = (可分配额 * 我的加权贡献分) / 总加权贡献分
- 如果 `useReputationWeighting = false`，按原始贡献分分配（传统方式）

### 3.2 使用示例

**方式一：仅用信誉阈值作为门槛（传统方式）**
```solidity
// 禁用信誉加权分配
contributorReward.setReputationWeighting(false);

// 设置信誉阈值（例如：5000 分，低于此值无法领取）
contributorReward.setReputationThreshold(5000);

// 设置节点信誉分数
contributorReward.setReputationScore(nodeAddress, 7500);

// 节点尝试领取奖励（检查信誉阈值，但奖励仍按贡献分分配）
contributorReward.claimReward(period, token);
```

**方式二：按信誉分加权分配（推荐）**
```solidity
// 启用按信誉分加权分配
contributorReward.setReputationWeighting(true);

// 设置信誉阈值（可选，例如：3000 分）
contributorReward.setReputationThreshold(3000);

// 设置节点信誉分数
contributorReward.setReputationScore(nodeAddress, 8000);

// 节点提交贡献证明时，会自动计算加权贡献分
// 节点领取奖励时，按加权贡献分分配（信誉分数越高，奖励越多）
contributorReward.claimReward(period, token);
```

**更新信誉分数并重新计算加权贡献分**
```solidity
// 更新节点信誉分数，并更新相关周期的总加权贡献分
string[] memory periods = new string[](2);
periods[0] = "2025-02-01_2025-02-08";
periods[1] = "2025-02-08_2025-02-15";
contributorReward.updateReputationAndRecalculateWeightedScore(
    nodeAddress,
    9000,  // 新的信誉分数
    periods
);
```

---

## 四、节点端实现

### 4.1 信誉数据收集

中继节点记录每个 peer 的：
- `BytesRelayed`：转发字节数
- `Violations`：违规次数
- `LastSeen`：最后活跃时间

### 4.2 信誉分数计算

使用 `node/internal/relay/reputation_score.go` 中的 `ReputationScore` 函数：

```go
import "github.com/P2P-P2P/p2p/node/internal/relay"

stats := &relay.PeerStats{
    BytesRelayed: 500e9,  // 500GB
    Violations:   2,
    LastSeen:     time.Now(),
}

activeDuration := 7 * 24 * time.Hour // 7 天
score := relay.ReputationScore(stats, activeDuration)
// score = 信誉分数 (0-10000)
```

### 4.3 信誉更新工具

使用 `node/cmd/reputation-updater` 工具定期更新链上信誉：

```bash
go run ./cmd/reputation-updater \
  -config config.yaml \
  -rpc https://sepolia.infura.io/v3/YOUR_KEY \
  -contract 0x851019107c4F3150D90f1629f6A646eBC1B1E286 \
  -key YOUR_PRIVATE_KEY \
  -reputation reputation.json
```

**reputation.json 格式**：
```json
[
  {
    "peerID": "12D3KooW...",
    "address": "0x...",
    "bytesRelayed": 500000000000,
    "violations": 2,
    "activeDays": 7.5,
    "reputationScore": 6500
  }
]
```

---

## 五、工作流程

### 5.1 信誉数据收集

1. **中继节点**：记录每个 peer 的转发量和违规次数
2. **定期汇总**：从多个中继节点收集信誉数据
3. **计算分数**：使用 `ReputationScore` 函数计算每个节点的信誉分数

### 5.2 链上更新

1. **生成信誉报告**：汇总所有节点的信誉数据
2. **调用合约**：使用 `setReputationScores` 批量更新
3. **设置阈值**：通过治理设置 `reputationThreshold`

### 5.3 奖励领取

**传统方式（useReputationWeighting = false）**：
1. **节点提交贡献证明**：正常提交，不受信誉影响
2. **尝试领取奖励**：调用 `claimReward`
3. **信誉检查**：合约自动检查 `reputationScore >= reputationThreshold`
4. **发放奖励**：按贡献分占比发放，满足阈值则发放，否则拒绝

**按信誉分分配（useReputationWeighting = true）**：
1. **节点提交贡献证明**：正常提交，合约自动计算加权贡献分
   - 加权贡献分 = 贡献分 * (信誉分数 / 10000)
   - 更新总加权贡献分
2. **尝试领取奖励**：调用 `claimReward`
3. **信誉检查**：检查 `reputationScore >= reputationThreshold`（如果设置了阈值）
4. **计算奖励**：
   - 我的加权贡献分 = 贡献分 * (信誉分数 / 10000)
   - 奖励 = (可分配额 * 我的加权贡献分) / 总加权贡献分
5. **发放奖励**：信誉分数越高，获得的奖励越多

---

## 六、配置建议

### 6.1 信誉机制配置

**方案一：仅用阈值作为门槛**
- `useReputationWeighting = false`
- `reputationThreshold = 3000`（中等门槛）
- 所有满足阈值的节点按贡献分平均分配

**方案二：按信誉分加权分配（推荐）**
- `useReputationWeighting = true`
- `reputationThreshold = 0` 或 `3000`（可选，作为最低门槛）
- 信誉分数高的节点获得更多奖励份额

**配置建议**：
- **初期（测试网）**：`useReputationWeighting = false`, `threshold = 0`（不启用，所有节点可领取）
- **稳定期**：`useReputationWeighting = true`, `threshold = 3000`（按信誉分分配，中等门槛）
- **成熟期**：`useReputationWeighting = true`, `threshold = 5000`（按信誉分分配，高门槛）

### 6.2 更新频率

建议每周更新一次信誉分数，与贡献周期同步。

### 6.3 违规定义

违规包括但不限于：
- 超过限流阈值被丢弃
- 发送恶意消息
- 长期离线后突然上线（可能为 Sybil 攻击）

---

## 七、优势

1. **开放性**：任何节点都可以加入，降低参与门槛
2. **激励质量**：通过奖励限制鼓励节点提供高质量服务
3. **抗 Sybil**：低信誉节点无法获得奖励，降低攻击动机
4. **灵活性**：可以通过治理调整阈值，适应不同阶段

---

## 八、注意事项

1. **信誉数据来源**：需要多个中继节点提供数据，避免单点故障
2. **数据真实性**：需要防止节点伪造信誉数据
3. **阈值设置**：阈值过高可能排除新节点，过低则无法有效筛选
4. **定期更新**：信誉分数需要定期更新，保持时效性

---

## 九、未来扩展

1. **去中心化信誉**：通过链上投票或预言机更新信誉
2. **动态阈值**：根据网络状态自动调整阈值
3. **信誉衰减**：长期不活跃的节点信誉分数逐渐降低
4. **信誉证明**：节点可以提交信誉证明，无需依赖中心化数据源

---

*本文档随实现进展随时更新。*
