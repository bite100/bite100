# ä¸Šçº¿å¥–åŠ±åˆ†å‘æœºåˆ¶å®ç°æŒ‡å—

> èŠ‚ç‚¹ç»‘å®šé’±åŒ… + ä¸Šçº¿æ—¶æ‰¹é‡ç©ºæŠ• - æ¿€åŠ±èŠ‚ç‚¹è¿è¥è€…å’Œå¼€å‘è€…

---

## ä¸€ã€æ ¸å¿ƒæ€è·¯

**ç›®æ ‡**ï¼šèŠ‚ç‚¹å¯åŠ¨/æ³¨å†Œæ—¶ç»‘å®šé’±åŒ… â†’ ä¸Šçº¿å‰ snapshot èŠ‚ç‚¹/è´¡çŒ® â†’ ä¸Šçº¿ç¬é—´é€šè¿‡åˆçº¦/å¤šç­¾æ‰¹é‡ç©ºæŠ•åˆ°ç»‘å®šçš„é’±åŒ…ã€‚

**ä»·å€¼**ï¼š
- è®©èŠ‚ç‚¹è¿è¥è€…æ›´æœ‰åŠ¨åŠ›é•¿æœŸè¿è¡ŒèŠ‚ç‚¹ï¼ˆä¸Šçº¿å°±æœ‰å³æ—¶å¥–åŠ±ï¼‰
- å¼€å‘è€…å¾—åˆ°è®¤å¯å’Œå¥–åŠ±
- é¡¹ç›®ä¸Šçº¿çš„ä¸€å¤§äº®ç‚¹

---

## äºŒã€èŠ‚ç‚¹ç»‘å®šé’±åŒ…ï¼ˆä¸‰ç§æ–¹å¼ï¼‰

### 2.1 é€‰é¡¹ Aï¼šé…ç½®æ–‡ä»¶ç»‘å®šï¼ˆæœ€ç®€å•ï¼Œç«‹å³å¯åŠ ï¼‰

**ä¼˜ç‚¹**ï¼šé›¶é“¾ä¸Šæˆæœ¬ï¼Œç”¨æˆ·å‹å¥½

**å®ç°æ­¥éª¤**ï¼š

#### æ­¥éª¤ 1ï¼šé…ç½®æ–‡ä»¶æ·»åŠ 

åœ¨ `node/config.yaml` ä¸­æ·»åŠ ï¼š

```yaml
reward:
  wallet: "0xYourWalletAddressHere"  # å¥–åŠ±æ¥æ”¶é’±åŒ…åœ°å€
  auto_register: true                 # æ˜¯å¦è‡ªåŠ¨æ³¨å†Œåˆ°é“¾ä¸Š
```

æˆ–åœ¨ `node/.env` ä¸­æ·»åŠ ï¼š

```bash
REWARD_WALLET=0xYourWalletAddressHere
```

#### æ­¥éª¤ 2ï¼šGo ä»£ç è¯»å–é…ç½®

æ›´æ–° `node/internal/config/config.go`ï¼š

```go
type Config struct {
    // ... ç°æœ‰é…ç½®
    Reward struct {
        Wallet      string `yaml:"wallet" env:"REWARD_WALLET"`
        AutoRegister bool   `yaml:"auto_register" env:"AUTO_REGISTER"`
    } `yaml:"reward"`
}
```

#### æ­¥éª¤ 3ï¼šèŠ‚ç‚¹å¯åŠ¨æ—¶å¹¿æ’­ç»‘å®šæ¶ˆæ¯

æ›´æ–° `node/cmd/node/main.go`ï¼š

```go
package main

import (
    "fmt"
    "github.com/libp2p/go-libp2p/core/peer"
    "crypto/sha256"
)

func registerNodeWallet(nodeID peer.ID, walletAddr string) {
    // æ–¹å¼1ï¼šé€šè¿‡ GossipSub å¹¿æ’­
    nodeIDHash := sha256.Sum256([]byte(nodeID.String()))
    
    message := map[string]interface{}{
        "type": "node_registration",
        "node_id": nodeID.String(),
        "node_id_hash": fmt.Sprintf("%x", nodeIDHash),
        "wallet": walletAddr,
        "timestamp": time.Now().Unix(),
    }
    
    // å¹¿æ’­åˆ° GossipSub topic: "node-registration"
    // p2pNode.Publish("node-registration", json.Marshal(message))
    
    // æ–¹å¼2ï¼šå†™åˆ°æœ¬åœ°æ—¥å¿—/æ–‡ä»¶ï¼Œä¾›åç»­ snapshot ç”¨
    logFile := fmt.Sprintf("node-registration-%s.json", nodeID.String()[:8])
    // å†™å…¥æ–‡ä»¶...
    
    fmt.Printf("âœ… èŠ‚ç‚¹é’±åŒ…å·²ç»‘å®š: %s -> %s\n", nodeID.String()[:8], walletAddr)
}
```

### 2.2 é€‰é¡¹ Bï¼šé“¾ä¸Šæ³¨å†Œï¼ˆæ›´é˜²ä½œå¼Šã€å¯éªŒè¯ï¼‰

**ä¼˜ç‚¹**ï¼šé˜²ä½œå¼Šã€å¯éªŒè¯ã€é€æ˜

**å®ç°æ­¥éª¤**ï¼š

#### æ­¥éª¤ 1ï¼šåˆ›å»º NodeRegistry åˆçº¦

åˆ›å»º `contracts/src/NodeRegistry.sol`ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title NodeRegistry
 * @notice èŠ‚ç‚¹é’±åŒ…ç»‘å®šæ³¨å†Œè¡¨ï¼Œç”¨äºä¸Šçº¿å¥–åŠ±åˆ†å‘
 */
contract NodeRegistry is Ownable {
    // nodeID hash => é’±åŒ…åœ°å€
    mapping(bytes32 => address) public nodeToWallet;
    
    // é’±åŒ…åœ°å€ => nodeID hashï¼ˆåå‘æ˜ å°„ï¼Œç”¨äºæŸ¥è¯¢ï¼‰
    mapping(address => bytes32) public walletToNode;
    
    // æ³¨å†Œæ—¶é—´è®°å½•
    mapping(bytes32 => uint256) public registrationTime;
    
    event NodeRegistered(bytes32 indexed nodeId, address indexed wallet, uint256 timestamp);
    event NodeUpdated(bytes32 indexed nodeId, address indexed oldWallet, address indexed newWallet);

    /**
     * @notice æ³¨å†ŒèŠ‚ç‚¹é’±åŒ…ç»‘å®š
     * @param nodeId èŠ‚ç‚¹ ID çš„ hashï¼ˆlibp2p peerID hashï¼‰
     * @param wallet å¥–åŠ±æ¥æ”¶é’±åŒ…åœ°å€
     */
    function register(bytes32 nodeId, address wallet) external {
        require(wallet != address(0), "Invalid wallet");
        require(nodeToWallet[nodeId] == address(0), "Node already registered");
        
        // å¦‚æœé’±åŒ…å·²ç»‘å®šå…¶ä»–èŠ‚ç‚¹ï¼Œä¸å…è®¸é‡å¤ç»‘å®š
        require(walletToNode[wallet] == bytes32(0) || walletToNode[wallet] == nodeId, "Wallet already bound");
        
        nodeToWallet[nodeId] = wallet;
        walletToNode[wallet] = nodeId;
        registrationTime[nodeId] = block.timestamp;
        
        emit NodeRegistered(nodeId, wallet, block.timestamp);
    }

    /**
     * @notice æ›´æ–°èŠ‚ç‚¹é’±åŒ…ï¼ˆéœ€ç­¾åéªŒè¯ï¼‰
     * @param nodeId èŠ‚ç‚¹ ID
     * @param newWallet æ–°é’±åŒ…åœ°å€
     * @param signature EIP-712 ç­¾åï¼ˆå¯é€‰ï¼Œå¢å¼ºå®‰å…¨æ€§ï¼‰
     */
    function updateWallet(bytes32 nodeId, address newWallet, bytes calldata signature) external {
        require(newWallet != address(0), "Invalid wallet");
        address oldWallet = nodeToWallet[nodeId];
        require(oldWallet != address(0), "Node not registered");
        
        // éªŒè¯ç­¾åï¼šåªæœ‰åŸé’±åŒ…æˆ–èŠ‚ç‚¹è¿è¥è€…å¯ä»¥æ›´æ–°
        // TODO: å®ç° EIP-712 ç­¾åéªŒè¯
        
        nodeToWallet[nodeId] = newWallet;
        walletToNode[oldWallet] = bytes32(0);
        walletToNode[newWallet] = nodeId;
        
        emit NodeUpdated(nodeId, oldWallet, newWallet);
    }

    /**
     * @notice æ‰¹é‡æŸ¥è¯¢èŠ‚ç‚¹é’±åŒ…ï¼ˆç”¨äº snapshotï¼‰
     */
    function getRegisteredNodes(uint256 offset, uint256 limit) external view returns (
        bytes32[] memory nodeIds,
        address[] memory wallets,
        uint256[] memory timestamps
    ) {
        // æ³¨æ„ï¼šæ­¤å‡½æ•°éœ€è¦éå†ï¼Œgas æ¶ˆè€—è¾ƒé«˜
        // å»ºè®®ç”¨äº‹ä»¶æ—¥å¿—ç¦»çº¿æŸ¥è¯¢ï¼Œæˆ–å®ç°ç´¢å¼•
        // è¿™é‡Œæä¾›ç®€åŒ–ç‰ˆæœ¬
        revert("Use event logs for batch queries");
    }
}
```

#### æ­¥éª¤ 2ï¼šéƒ¨ç½²åˆçº¦

```bash
cd contracts
forge script script/DeployNodeRegistry.s.sol --rpc-url $SEPOLIA_RPC --broadcast
```

#### æ­¥éª¤ 3ï¼šèŠ‚ç‚¹å¯åŠ¨è„šæœ¬æ³¨å†Œ

åˆ›å»º `node/scripts/register-node.sh`ï¼š

```bash
#!/bin/bash

# é…ç½®
NODE_ID=$(cat node/peerkey | head -1)  # ä»èŠ‚ç‚¹é…ç½®è¯»å–
WALLET_ADDR="${REWARD_WALLET:-0xYourWalletAddress}"
REGISTRY_ADDR="0x..."  # NodeRegistry åˆçº¦åœ°å€
PRIVATE_KEY="${NODE_PRIVATE_KEY}"  # èŠ‚ç‚¹è¿è¥è€…ç§é’¥ï¼ˆæˆ–ä½¿ç”¨ relayerï¼‰

# è®¡ç®— nodeID hash
NODE_ID_HASH=$(cast keccak "$NODE_ID")

# è°ƒç”¨åˆçº¦æ³¨å†Œ
cast send --rpc-url $SEPOLIA_RPC \
  $REGISTRY_ADDR \
  "register(bytes32,address)" \
  $NODE_ID_HASH \
  $WALLET_ADDR \
  --private-key $PRIVATE_KEY

echo "âœ… èŠ‚ç‚¹å·²æ³¨å†Œ: $NODE_ID_HASH -> $WALLET_ADDR"
```

### 2.3 é€‰é¡¹ Cï¼šå‰ç«¯/CLI ç»‘å®šï¼ˆç”¨æˆ·æœ€å‹å¥½ï¼‰

**ä¼˜ç‚¹**ï¼šç”¨æˆ·å‹å¥½ï¼Œæ— éœ€ä¿®æ”¹èŠ‚ç‚¹ä»£ç 

**å®ç°æ­¥éª¤**ï¼š

#### æ­¥éª¤ 1ï¼šå‰ç«¯æ·»åŠ "èŠ‚ç‚¹ç®¡ç†"é¡µé¢

åˆ›å»º `frontend/src/components/NodeManagement.tsx`ï¼š

```typescript
import { useState } from 'react'
import { useAccount, useContractWrite, usePrepareContractWrite } from 'wagmi'
import { NODE_REGISTRY_ADDRESS, NODE_REGISTRY_ABI } from '../config'
import { keccak256, toUtf8Bytes } from 'ethers'

export function NodeManagement() {
  const { address } = useAccount()
  const [nodeId, setNodeId] = useState('')

  // è®¡ç®— nodeID hash
  const nodeIdHash = nodeId ? keccak256(toUtf8Bytes(nodeId)) : '0x0'

  const { config } = usePrepareContractWrite({
    address: NODE_REGISTRY_ADDRESS,
    abi: NODE_REGISTRY_ABI,
    functionName: 'register',
    args: [nodeIdHash, address || '0x0'],
    enabled: !!nodeId && !!address,
  })

  const { write, isLoading, isSuccess } = useContractWrite(config)

  return (
    <div className="card">
      <h3 className="text-lg font-bold mb-3">èŠ‚ç‚¹é’±åŒ…ç»‘å®š</h3>
      
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">
            èŠ‚ç‚¹ IDï¼ˆä»èŠ‚ç‚¹æ—¥å¿—è¯»å–ï¼‰
          </label>
          <input
            type="text"
            value={nodeId}
            onChange={(e) => setNodeId(e.target.value)}
            placeholder="12D3KooW..."
            className="input w-full"
          />
          <p className="text-xs text-gray-500 mt-1">
            èŠ‚ç‚¹ ID å¯åœ¨èŠ‚ç‚¹å¯åŠ¨æ—¥å¿—ä¸­æ‰¾åˆ°
          </p>
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">
            å¥–åŠ±æ¥æ”¶é’±åŒ…
          </label>
          <div className="input bg-gray-100">
            {address || 'è¯·å…ˆè¿æ¥é’±åŒ…'}
          </div>
        </div>

        <button
          onClick={() => write?.()}
          disabled={!write || isLoading || !nodeId || !address}
          className="btn primary w-full"
        >
          {isLoading ? 'æ³¨å†Œä¸­...' : 'ç»‘å®šé’±åŒ…'}
        </button>

        {isSuccess && (
          <div className="bg-green-50 border border-green-200 rounded p-3">
            <p className="text-green-800 text-sm">
              âœ… èŠ‚ç‚¹é’±åŒ…å·²ç»‘å®šï¼ä¸Šçº¿æ—¶å°†è‡ªåŠ¨å‘æ”¾å¥–åŠ±åˆ°æ­¤é’±åŒ…ã€‚
            </p>
          </div>
        )}
      </div>
    </div>
  )
}
```

#### æ­¥éª¤ 2ï¼šCLI å‘½ä»¤ï¼ˆå¯é€‰ï¼‰

åˆ›å»º `node/cmd/register/main.go`ï¼š

```go
package main

import (
    "flag"
    "fmt"
    "os"
    
    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    nodeID := flag.String("node-id", "", "Node ID (libp2p peerID)")
    walletAddr := flag.String("wallet", "", "Wallet address")
    registryAddr := flag.String("registry", "", "NodeRegistry contract address")
    flag.Parse()
    
    // è¿æ¥ RPC
    client, _ := ethclient.Dial(os.Getenv("RPC_URL"))
    
    // è°ƒç”¨åˆçº¦æ³¨å†Œ
    // ... å®ç°åˆçº¦è°ƒç”¨é€»è¾‘
    
    fmt.Printf("âœ… èŠ‚ç‚¹å·²æ³¨å†Œ: %s -> %s\n", *nodeID, *walletAddr)
}
```

---

## ä¸‰ã€ä¸Šçº¿æ—¶æ‰¹é‡å‘æ”¾ï¼ˆä¸‰ç§æ–¹å¼ï¼‰

### 3.1 æ–¹å¼ 1ï¼šMerkle Airdropï¼ˆæ¨èï¼Œgas é«˜æ•ˆï¼‰

**ä¼˜ç‚¹**ï¼šGas é«˜æ•ˆï¼Œç”¨æˆ·æŒ‰éœ€é¢†å–

**å®ç°æ­¥éª¤**ï¼š

#### æ­¥éª¤ 1ï¼šåˆ›å»º MerkleDistributor åˆçº¦

**å·²å®ç°**ï¼š`contracts/src/MerkleDistributor.sol` ä¸ `node/cmd/merkle-distributor` å·¥å…·å·²å°±ç»ªã€‚ç”Ÿæˆ root/proof ä½¿ç”¨ï¼š

```bash
go run ./cmd/merkle-distributor -list rewards.csv [-proof-for 0xåœ°å€]
```

ä¸‹æ–¹ä¸ºå‚è€ƒå®ç°ï¼ˆä¸å½“å‰åˆçº¦ä¸€è‡´ï¼‰ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/**
 * @title MerkleDistributor
 * @notice åŸºäº Merkle Tree çš„å¥–åŠ±åˆ†å‘åˆçº¦
 */
contract MerkleDistributor is Ownable {
    IERC20 public immutable token;
    bytes32 public merkleRoot;
    uint256 public totalAmount;
    
    mapping(address => bool) public claimed;
    
    event Claimed(address indexed account, uint256 amount);
    event MerkleRootUpdated(bytes32 indexed newRoot, uint256 totalAmount);

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    /**
     * @notice è®¾ç½® Merkle Rootï¼ˆä»… Ownerï¼Œä¸Šçº¿å‰è®¾ç½®ï¼‰
     */
    function setMerkleRoot(bytes32 _merkleRoot, uint256 _totalAmount) external onlyOwner {
        merkleRoot = _merkleRoot;
        totalAmount = _totalAmount;
        emit MerkleRootUpdated(_merkleRoot, _totalAmount);
    }

    /**
     * @notice é¢†å–å¥–åŠ±
     * @param index åœ¨ Merkle Tree ä¸­çš„ç´¢å¼•
     * @param account é¢†å–åœ°å€
     * @param amount å¥–åŠ±é‡‘é¢
     * @param merkleProof Merkle è¯æ˜
     */
    function claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external {
        require(!claimed[account], "Already claimed");
        
        // éªŒè¯ Merkle è¯æ˜
        bytes32 node = keccak256(abi.encodePacked(index, account, amount));
        require(
            MerkleProof.verify(merkleProof, merkleRoot, node),
            "Invalid merkle proof"
        );
        
        claimed[account] = true;
        require(token.transfer(account, amount), "Transfer failed");
        
        emit Claimed(account, amount);
    }

    /**
     * @notice æ‰¹é‡é¢†å–ï¼ˆå¯é€‰ï¼Œgas ä¼˜åŒ–ï¼‰
     */
    function batchClaim(
        uint256[] calldata indices,
        address[] calldata accounts,
        uint256[] calldata amounts,
        bytes32[][] calldata merkleProofs
    ) external {
        require(
            indices.length == accounts.length &&
            accounts.length == amounts.length &&
            amounts.length == merkleProofs.length,
            "Length mismatch"
        );
        
        for (uint256 i = 0; i < accounts.length; i++) {
            if (!claimed[accounts[i]]) {
                bytes32 node = keccak256(abi.encodePacked(indices[i], accounts[i], amounts[i]));
                require(
                    MerkleProof.verify(merkleProofs[i], merkleRoot, node),
                    "Invalid merkle proof"
                );
                claimed[accounts[i]] = true;
                require(token.transfer(accounts[i], amounts[i]), "Transfer failed");
                emit Claimed(accounts[i], amounts[i]);
            }
        }
    }

    /**
     * @notice ç´§æ€¥æå–ï¼ˆä»… Ownerï¼‰
     */
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), "Transfer failed");
    }
}
```

#### æ­¥éª¤ 2ï¼šç”Ÿæˆ Merkle Tree

åˆ›å»º `scripts/generate-merkle-tree.js`ï¼š

```javascript
const { MerkleTree } = require('merkletreejs')
const keccak256 = require('keccak256')
const fs = require('fs')

// å¥–åŠ±åˆ—è¡¨ï¼ˆä» snapshot ç”Ÿæˆï¼‰
const rewards = [
  { address: '0x1234...', amount: '1000000000000000000' }, // 1 USDT (18 decimals)
  { address: '0x5678...', amount: '2000000000000000000' }, // 2 USDT
  // ... æ›´å¤šåœ°å€
]

// ç”Ÿæˆ Merkle Tree
const leaves = rewards.map((r, index) =>
  keccak256(
    Buffer.concat([
      Buffer.from(index.toString().padStart(64, '0'), 'hex'),
      Buffer.from(r.address.slice(2), 'hex'),
      Buffer.from(BigInt(r.amount).toString(16).padStart(64, '0'), 'hex'),
    ])
  )
)

const tree = new MerkleTree(leaves, keccak256, { sortPairs: true })
const root = tree.getRoot()

// ç”Ÿæˆè¯æ˜æ–‡ä»¶
const proofs = rewards.map((r, index) => {
  const leaf = leaves[index]
  const proof = tree.getProof(leaf)
  return {
    index,
    address: r.address,
    amount: r.amount,
    proof: proof.map(p => '0x' + p.data.toString('hex')),
  }
})

// ä¿å­˜ç»“æœ
fs.writeFileSync('merkle-tree.json', JSON.stringify({
  root: '0x' + root.toString('hex'),
  totalAmount: rewards.reduce((sum, r) => sum + BigInt(r.amount), 0n).toString(),
  proofs,
}, null, 2))

console.log('âœ… Merkle Tree å·²ç”Ÿæˆ')
console.log('Root:', '0x' + root.toString('hex'))
console.log('Total amount:', rewards.reduce((sum, r) => sum + BigInt(r.amount), 0n).toString())
```

#### æ­¥éª¤ 3ï¼šå‰ç«¯é¢†å–ç•Œé¢

åˆ›å»º `frontend/src/components/ClaimAirdrop.tsx`ï¼š

```typescript
import { useState, useEffect } from 'react'
import { useAccount, useContractWrite, usePrepareContractWrite } from 'wagmi'
import { MERKLE_DISTRIBUTOR_ADDRESS, MERKLE_DISTRIBUTOR_ABI } from '../config'

export function ClaimAirdrop() {
  const { address } = useAccount()
  const [proof, setProof] = useState<any>(null)
  const [amount, setAmount] = useState<bigint>(0n)

  // ä» API æˆ–æ–‡ä»¶åŠ è½½ç”¨æˆ·çš„ Merkle è¯æ˜
  useEffect(() => {
    if (!address) return
    
    fetch(`/api/merkle-proof/${address}`)
      .then(res => res.json())
      .then(data => {
        setProof(data.proof)
        setAmount(BigInt(data.amount))
      })
  }, [address])

  const { config } = usePrepareContractWrite({
    address: MERKLE_DISTRIBUTOR_ADDRESS,
    abi: MERKLE_DISTRIBUTOR_ABI,
    functionName: 'claim',
    args: proof ? [
      proof.index,
      address,
      amount,
      proof.proof,
    ] : undefined,
    enabled: !!proof && !!address,
  })

  const { write, isLoading, isSuccess } = useContractWrite(config)

  if (!address) {
    return <div className="card">è¯·å…ˆè¿æ¥é’±åŒ…</div>
  }

  if (!proof) {
    return <div className="card">æŸ¥è¯¢ä¸­...</div>
  }

  return (
    <div className="card">
      <h3 className="text-lg font-bold mb-3">é¢†å–ä¸Šçº¿å¥–åŠ±</h3>
      
      <div className="space-y-4">
        <div className="flex justify-between">
          <span>å¯é¢†å–å¥–åŠ±ï¼š</span>
          <span className="text-2xl font-bold text-green-600">
            {(Number(amount) / 1e18).toFixed(2)} USDT
          </span>
        </div>

        <button
          onClick={() => write?.()}
          disabled={!write || isLoading}
          className="btn primary w-full py-4"
        >
          {isLoading ? 'é¢†å–ä¸­...' : 'ç«‹å³é¢†å–'}
        </button>

        {isSuccess && (
          <div className="bg-green-50 border border-green-200 rounded p-3">
            <p className="text-green-800">âœ… å¥–åŠ±å·²é¢†å–ï¼</p>
          </div>
        )}
      </div>
    </div>
  )
}
```

### 3.2 æ–¹å¼ 2ï¼šæ‰¹é‡ Multisig æ¨é€ï¼ˆç®€å•ç›´æ¥ï¼‰

**ä¼˜ç‚¹**ï¼šç®€å•ç›´æ¥ï¼Œæ— éœ€ç”¨æˆ·æ“ä½œ

**å®ç°æ­¥éª¤**ï¼š

#### æ­¥éª¤ 1ï¼šå‡†å¤‡å¥–åŠ±åˆ—è¡¨

åˆ›å»º `scripts/prepare-airdrop-list.js`ï¼š

```javascript
// ä» snapshot ç”Ÿæˆå¥–åŠ±åˆ—è¡¨
const rewards = [
  { address: '0x1234...', amount: '1000000000000000000' },
  { address: '0x5678...', amount: '2000000000000000000' },
  // ...
]

// ä¿å­˜ä¸º JSON
fs.writeFileSync('airdrop-list.json', JSON.stringify(rewards, null, 2))
```

#### æ­¥éª¤ 2ï¼šæ‰¹é‡è½¬è´¦è„šæœ¬

åˆ›å»º `scripts/batch-transfer.js`ï¼š

```javascript
const { ethers } = require('ethers')
const rewards = require('./airdrop-list.json')

async function batchTransfer() {
  const provider = new ethers.JsonRpcProvider(process.env.RPC_URL)
  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider)
  const token = new ethers.Contract(USDT_ADDRESS, ERC20_ABI, wallet)

  for (const reward of rewards) {
    try {
      const tx = await token.transfer(reward.address, reward.amount)
      console.log(`âœ… å·²è½¬è´¦åˆ° ${reward.address}: ${tx.hash}`)
      await tx.wait()
    } catch (err) {
      console.error(`âŒ è½¬è´¦å¤±è´¥ ${reward.address}:`, err)
    }
  }
}

batchTransfer()
```

#### æ­¥éª¤ 3ï¼šä½¿ç”¨ Gnosis Safe Multisig

1. åˆ›å»º Gnosis Safe å¤šç­¾é’±åŒ…
2. é¢„å­˜ USDT åˆ°å¤šç­¾é’±åŒ…
3. ä½¿ç”¨ Gnosis Safe API æ‰¹é‡åˆ›å»ºäº¤æ˜“
4. å¤šç­¾æ‰¹å‡†åæ‰¹é‡æ‰§è¡Œ

### 3.3 æ–¹å¼ 3ï¼šè‡ªåŠ¨ä» FeeDistributor æ‹‰å–

**ä¼˜ç‚¹**ï¼šå¯æŒç»­ï¼Œæ— éœ€é¢„å­˜èµ„é‡‘

**å®ç°æ­¥éª¤**ï¼š

åœ¨ `FeeDistributor` åˆçº¦ä¸­æ·»åŠ ä¸Šçº¿å¥–åŠ±é€»è¾‘ï¼š

```solidity
mapping(address => uint256) public launchRewards;  // ä¸Šçº¿å¥–åŠ±é¢åº¦
mapping(address => bool) public launchRewardClaimed;  // æ˜¯å¦å·²é¢†å–

function claimLaunchReward() external {
    require(!launchRewardClaimed[msg.sender], "Already claimed");
    require(launchRewards[msg.sender] > 0, "No reward");
    
    uint256 amount = launchRewards[msg.sender];
    launchRewards[msg.sender] = 0;
    launchRewardClaimed[msg.sender] = true;
    
    // ä»æ‰‹ç»­è´¹æ± ä¸­æå–
    require(token.transfer(msg.sender, amount), "Transfer failed");
    emit LaunchRewardClaimed(msg.sender, amount);
}
```

---

## å››ã€ç§¯åˆ†è§„åˆ™ç»†åŒ–

### 4.1 å¼€å‘è€…ç§¯åˆ†

**æ¥æº**ï¼š
- GitHub PR/commitsï¼ˆè‡ªåŠ¨ç»Ÿè®¡ï¼‰
- æ–‡æ¡£è´¡çŒ®ï¼ˆæ‰‹åŠ¨å®¡æ ¸ï¼‰
- æµ‹è¯•è´¡çŒ®ï¼ˆæ‰‹åŠ¨å®¡æ ¸ï¼‰

**è§„åˆ™**ï¼š
- **ä»…å¼€å‘è€…ç§¯åˆ†**æŒ‰ **1 ç§¯åˆ† = 1 USDT**ï¼ˆæˆ–ç­‰å€¼ç¨³å®šå¸ï¼‰å…‘æ¢å‘æ”¾
- ä¸Šçº¿å‰ç´¯è®¡ï¼Œä¸»ç½‘ä¸Šçº¿æ—¶å‘æ”¾
- æœ€å°è´¡çŒ®ï¼š1 PR æˆ– 100 è¡Œä»£ç 

### 4.2 èŠ‚ç‚¹ç§¯åˆ†

**æ¥æº**ï¼š
- è¿è¡Œæ—¶é•¿ï¼ˆæ¯å¤©åœ¨çº¿è®¡ 1 èŠ‚ç‚¹ç§¯åˆ†ï¼‰
- æ’®åˆè®¢å•é‡ï¼ˆæ¯ 100 ç¬”è®¢å•è®¡ 1 èŠ‚ç‚¹ç§¯åˆ†ï¼‰
- ç½‘ç»œè´¡çŒ®ï¼ˆä¸­ç»§ã€å­˜å‚¨ç­‰ï¼‰

**è§„åˆ™**ï¼š
- èŠ‚ç‚¹ç§¯åˆ†**ä¸**æŒ‰ 1 ç§¯åˆ† = 1 USDTï¼›æŒ‰æ€»æ± ä¸­èŠ‚ç‚¹å æ¯”ï¼ˆå¦‚ 30%ï¼‰ä¸ç§¯åˆ†æƒé‡åˆ†é…
- æœ€å°è¿è¡Œæ—¶é•¿ï¼š7 å¤©
- é˜²åˆ·ï¼šéœ€å¿ƒè·³éªŒè¯ã€æœ€å°æ’®åˆé‡

### 4.3 æ€»æ± åˆ†é…

**å»ºè®®åˆ†é…**ï¼š
- 50% ç»™å¼€å‘è€…ï¼ˆä¸Šçº¿æ—¶å‘æ”¾ï¼‰
- 30% ç»™èŠ‚ç‚¹è¿è¥è€…ï¼ˆä¸Šçº¿æ—¶å‘æ”¾ï¼‰
- 20% é¢„ç•™ï¼ˆä»æ‰‹ç»­è´¹é•¿æœŸåˆ†æˆï¼‰

---

## äº”ã€å®æ–½æ­¥éª¤ï¼ˆå¿«é€Ÿ Roadmapï¼‰

### é˜¶æ®µ 1ï¼šèŠ‚ç‚¹ç»‘å®šï¼ˆ1 å‘¨ï¼‰

1. âœ… å†³å®šç»‘å®šæ–¹å¼ï¼ˆæ¨èé€‰é¡¹ A + B ç»“åˆï¼‰
2. âœ… åˆ›å»º NodeRegistry åˆçº¦
3. âœ… éƒ¨ç½²åˆ° Sepolia æµ‹è¯•ç½‘
4. âœ… ä¿®æ”¹ node å¯åŠ¨è„šæœ¬/Go ä»£ç ï¼šæ”¯æŒç»‘å®š + æ³¨å†Œ
5. âœ… å‰ç«¯åŠ "ç»‘å®šé’±åŒ…"æŒ‰é’®ï¼ˆå¯é€‰ï¼‰

### é˜¶æ®µ 2ï¼šSnapshot å‡†å¤‡ï¼ˆ1 å‘¨ï¼‰

1. âœ… å†™ snapshot è„šæœ¬ï¼š
   - æ‰«æé“¾ä¸Šäº‹ä»¶ï¼ˆNodeRegisteredï¼‰
   - æ”¶é›†å¼€å‘è€…è´¡çŒ®ï¼ˆGitHub APIï¼‰
   - ç”Ÿæˆç§¯åˆ†è¡¨
2. âœ… ç”Ÿæˆ Merkle Treeï¼ˆå¦‚æœç”¨æ–¹å¼ 1ï¼‰
3. âœ… å®¡æ ¸å’Œç¡®è®¤å¥–åŠ±åˆ—è¡¨

### é˜¶æ®µ 3ï¼šä¸Šçº¿å‘æ”¾ï¼ˆä¸Šçº¿æ—¶ï¼‰

1. âœ… Governance ææ¡ˆï¼šæ‰¹å‡†ä¸Šçº¿ + å¥–åŠ±æ± 
2. âœ… è®¾ç½® Merkle Rootï¼ˆå¦‚æœç”¨æ–¹å¼ 1ï¼‰
3. âœ… æ‰¹é‡è½¬è´¦ï¼ˆå¦‚æœç”¨æ–¹å¼ 2ï¼‰
4. âœ… ç”¨æˆ·é¢†å–ç•Œé¢ä¸Šçº¿

---

## ä¸ƒã€ç»Ÿä¸€å¥–åŠ±é¢†å–æœºåˆ¶ï¼ˆæ¨èå®ç°ï¼‰

### 7.1 æ ¸å¿ƒé€»è¾‘

**ç›®æ ‡**ï¼šäº¤æ˜“æ‰€è®°å½•é’±åŒ…åœ°å€ï¼Œå¼€å‘è€…ç§¯åˆ†ç»‘å®šåˆ°é’±åŒ…ï¼Œé’±åŒ…åœ°å€å…³è”çš„èŠ‚ç‚¹ä¹Ÿå¯ä»¥é¢†å–ã€‚åŒä¸€ä¸ªé’±åŒ…æ—¢èƒ½é¢†å¼€å‘è€…ç§¯åˆ†ï¼Œä¹Ÿèƒ½é¢†èŠ‚ç‚¹è¿è¡Œå¥–åŠ±ï¼Œä¸€é”®é¢†å–æ‰€æœ‰å¥–åŠ±ã€‚

**ä¼˜åŠ¿**ï¼š
- âœ… é¿å…å¤šé’±åŒ…ç®¡ç†
- âœ… å‡å°‘é¢†å–æ‘©æ“¦
- âœ… æ¿€åŠ±å¼€å‘è€…æ—¢è´¡çŒ®ä»£ç åˆè¿è¡ŒèŠ‚ç‚¹ï¼ˆåŒé‡èº«ä»½ï¼‰

### 7.2 é’±åŒ…ç»‘å®šä¸è®°å½•æ–¹å¼

#### æ–¹å¼ 1ï¼šå‰ç«¯ç»‘å®šï¼ˆæœ€æ¨èï¼Œç”¨æˆ·å‹å¥½ï¼‰

**å®ç°æ­¥éª¤**ï¼š

åˆ›å»º `frontend/src/components/RewardBinding.tsx`ï¼š

```typescript
import { useState } from 'react'
import { useAccount, useSignMessage, useContractWrite, usePrepareContractWrite } from 'wagmi'
import { CONTRIBUTOR_REWARD_ADDRESS, CONTRIBUTOR_REWARD_ABI } from '../config'
import { keccak256, toUtf8Bytes } from 'ethers'

export function RewardBinding() {
  const { address } = useAccount()
  const [nodeId, setNodeId] = useState('')
  const [bindingStatus, setBindingStatus] = useState<'idle' | 'signing' | 'success'>('idle')

  // EIP-712 ç­¾åç»‘å®š
  const { signMessageAsync } = useSignMessage({
    message: `Bind wallet to P2P-P2P project for rewards\n\nWallet: ${address}\nNode ID: ${nodeId || 'N/A'}`,
    onSuccess: async (signature) => {
      // è°ƒç”¨åˆçº¦ç»‘å®š
      await bindWallet(signature)
    },
  })

  // åˆçº¦ç»‘å®šå‡½æ•°
  const { config } = usePrepareContractWrite({
    address: CONTRIBUTOR_REWARD_ADDRESS,
    abi: CONTRIBUTOR_REWARD_ABI,
    functionName: 'bindWallet',
    args: nodeId ? [keccak256(toUtf8Bytes(nodeId)), address || '0x0'] : [keccak256(toUtf8Bytes('')), address || '0x0'],
    enabled: !!address,
  })

  const { write: bindWallet, isLoading } = useContractWrite({
    ...config,
    onSuccess: () => {
      setBindingStatus('success')
    },
  })

  return (
    <div className="card">
      <h3 className="text-lg font-bold mb-3">å¥–åŠ±é’±åŒ…ç»‘å®š</h3>
      
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">
            å½“å‰é’±åŒ…åœ°å€
          </label>
          <div className="input bg-gray-100">
            {address || 'è¯·å…ˆè¿æ¥é’±åŒ…'}
          </div>
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">
            èŠ‚ç‚¹ IDï¼ˆå¯é€‰ï¼Œå¦‚æœè¿è¡ŒèŠ‚ç‚¹ï¼‰
          </label>
          <input
            type="text"
            value={nodeId}
            onChange={(e) => setNodeId(e.target.value)}
            placeholder="12D3KooW...ï¼ˆå¯é€‰ï¼‰"
            className="input w-full"
          />
          <p className="text-xs text-gray-500 mt-1">
            å¦‚æœè¿è¡ŒèŠ‚ç‚¹ï¼Œè¾“å…¥èŠ‚ç‚¹ ID å¯åŒæ—¶é¢†å–èŠ‚ç‚¹å¥–åŠ±
          </p>
        </div>

        <button
          onClick={() => signMessageAsync()}
          disabled={!address || isLoading}
          className="btn primary w-full"
        >
          {isLoading ? 'ç»‘å®šä¸­...' : 'ç»‘å®šé’±åŒ…'}
        </button>

        {bindingStatus === 'success' && (
          <div className="bg-green-50 border border-green-200 rounded p-3">
            <p className="text-green-800 text-sm">
              âœ… é’±åŒ…å·²ç»‘å®šï¼å¼€å‘è€…ç§¯åˆ†å’ŒèŠ‚ç‚¹å¥–åŠ±å°†ç»Ÿä¸€å‘æ”¾åˆ°æ­¤é’±åŒ…ã€‚
            </p>
          </div>
        )}
      </div>
    </div>
  )
}
```

#### æ–¹å¼ 2ï¼šèŠ‚ç‚¹å¯åŠ¨æ—¶ç»‘å®š

åœ¨ `node/config.yaml` ä¸­æ·»åŠ ï¼š

```yaml
reward:
  wallet: "0xYourWalletAddressHere"
  auto_bind: true
```

èŠ‚ç‚¹å¯åŠ¨æ—¶è‡ªåŠ¨è°ƒç”¨åˆçº¦ç»‘å®šï¼ˆè§å‰é¢çš„ NodeRegistry å®ç°ï¼‰ã€‚

#### æ–¹å¼ 3ï¼šCLI å‘½ä»¤ç»‘å®š

```bash
p2p-hub bind-wallet 0xYourAddress --node-id 12D3KooW...
```

### 7.3 åˆçº¦æ‰©å±•ï¼ˆContributorRewardï¼‰

æ‰©å±• `contracts/src/ContributorReward.sol`ï¼š

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "./Governance.sol";

/**
 * @title ContributorReward (æ‰©å±•ç‰ˆ)
 * @notice ç»Ÿä¸€å¥–åŠ±é¢†å–ï¼šå¼€å‘è€…ç§¯åˆ† + èŠ‚ç‚¹å¥–åŠ±
 */
contract ContributorReward is Ownable {
    IERC20 public immutable rewardToken;  // USDT æˆ–é¡¹ç›®ä»£å¸
    Governance public governance;
    
    // ç§¯åˆ†è®°å½•
    mapping(address => uint256) public devPoints;          // å¼€å‘è€…ç§¯åˆ†
    mapping(address => uint256) public nodePoints;         // èŠ‚ç‚¹ç§¯åˆ†
    mapping(address => uint256) public feeRewards;         // æ‰‹ç»­è´¹åˆ†æˆå¥–åŠ±
    
    // èŠ‚ç‚¹ç»‘å®š
    mapping(bytes32 => address) public nodeIdToWallet;    // libp2p nodeID hash => é’±åŒ…
    mapping(address => bytes32) public walletToNodeId;    // é’±åŒ… => nodeID hash
    
    // é¢†å–è®°å½•
    mapping(address => bool) public hasClaimedLaunchReward; // æ˜¯å¦å·²é¢†å–ä¸Šçº¿å¥–åŠ±
    
    event WalletBound(address indexed wallet, bytes32 indexed nodeId);
    event PointsAllocated(address indexed wallet, uint256 devAmount, uint256 nodeAmount);
    event RewardsClaimed(address indexed wallet, uint256 totalAmount, uint256 devAmount, uint256 nodeAmount, uint256 feeAmount);

    constructor(address _rewardToken, address _governance) Ownable(msg.sender) {
        rewardToken = IERC20(_rewardToken);
        governance = Governance(_governance);
    }

    /**
     * @notice ç»‘å®šé’±åŒ…ï¼ˆå¼€å‘è€…/èŠ‚ç‚¹è¿è¥è€…ï¼‰
     * @param nodeId èŠ‚ç‚¹ ID hashï¼ˆlibp2p peerID hashï¼‰ï¼ŒéèŠ‚ç‚¹ç”¨æˆ·ä¼  bytes32(0)
     * @param wallet å¥–åŠ±æ¥æ”¶é’±åŒ…åœ°å€
     */
    function bindWallet(bytes32 nodeId, address wallet) external {
        require(wallet != address(0), "Invalid wallet");
        require(msg.sender == wallet, "Only wallet owner can bind");
        
        // å¦‚æœæä¾›äº† nodeIdï¼Œè®°å½•èŠ‚ç‚¹ç»‘å®š
        if (nodeId != bytes32(0)) {
            require(nodeIdToWallet[nodeId] == address(0), "Node already bound");
            nodeIdToWallet[nodeId] = wallet;
            walletToNodeId[wallet] = nodeId;
        }
        
        emit WalletBound(wallet, nodeId);
    }

    /**
     * @notice æ‰¹é‡åˆ†é…ç§¯åˆ†ï¼ˆä»… Governanceï¼‰
     * @param wallets é’±åŒ…åœ°å€åˆ—è¡¨
     * @param devAmounts å¼€å‘è€…ç§¯åˆ†åˆ—è¡¨
     * @param nodeAmounts èŠ‚ç‚¹ç§¯åˆ†åˆ—è¡¨
     */
    function allocatePoints(
        address[] calldata wallets,
        uint256[] calldata devAmounts,
        uint256[] calldata nodeAmounts
    ) external {
        require(
            msg.sender == address(governance) || governance.hasRole(governance.GOVERNOR_ROLE(), msg.sender),
            "Only governance"
        );
        require(
            wallets.length == devAmounts.length && devAmounts.length == nodeAmounts.length,
            "Length mismatch"
        );
        
        for (uint256 i = 0; i < wallets.length; i++) {
            devPoints[wallets[i]] += devAmounts[i];
            nodePoints[wallets[i]] += nodeAmounts[i];
            emit PointsAllocated(wallets[i], devAmounts[i], nodeAmounts[i]);
        }
    }

    /**
     * @notice ä¸€é”®é¢†å–æ‰€æœ‰å¥–åŠ±ï¼ˆå¼€å‘è€…ç§¯åˆ† + èŠ‚ç‚¹ç§¯åˆ† + æ‰‹ç»­è´¹åˆ†æˆï¼‰
     */
    function claimRewards() external {
        uint256 devAmount = devPoints[msg.sender];
        uint256 nodeAmount = nodePoints[msg.sender];
        uint256 feeAmount = feeRewards[msg.sender];
        uint256 total = devAmount + nodeAmount + feeAmount;
        
        require(total > 0, "No rewards");
        
        // æ¸…é›¶ç§¯åˆ†
        devPoints[msg.sender] = 0;
        nodePoints[msg.sender] = 0;
        feeRewards[msg.sender] = 0;
        
        // è½¬è´¦ USDTï¼ˆä»…å¼€å‘è€…ç§¯åˆ† 1 ç§¯åˆ†=1 USDTï¼›èŠ‚ç‚¹/æ‰‹ç»­è´¹æŒ‰æ± åˆ†é…ï¼Œæ­¤å¤„ä¸ºç¤ºæ„ï¼‰
        require(rewardToken.transfer(msg.sender, total), "Transfer failed");
        
        emit RewardsClaimed(msg.sender, total, devAmount, nodeAmount, feeAmount);
    }

    /**
     * @notice æŸ¥è¯¢æ€»å¥–åŠ±ï¼ˆå‰ç«¯æ˜¾ç¤ºç”¨ï¼‰
     */
    function getTotalRewards(address wallet) external view returns (
        uint256 devAmount,
        uint256 nodeAmount,
        uint256 feeAmount,
        uint256 total
    ) {
        devAmount = devPoints[wallet];
        nodeAmount = nodePoints[wallet];
        feeAmount = feeRewards[wallet];
        total = devAmount + nodeAmount + feeAmount;
    }

    /**
     * @notice ä» FeeDistributor åˆ†é…æ‰‹ç»­è´¹åˆ†æˆï¼ˆä»… Governanceï¼‰
     */
    function distributeFeeRewards(address[] calldata wallets, uint256[] calldata amounts) external {
        require(
            msg.sender == address(governance) || governance.hasRole(governance.GOVERNOR_ROLE(), msg.sender),
            "Only governance"
        );
        require(wallets.length == amounts.length, "Length mismatch");
        
        for (uint256 i = 0; i < wallets.length; i++) {
            feeRewards[wallets[i]] += amounts[i];
        }
    }

    /**
     * @notice ç´§æ€¥æå–ï¼ˆä»… Ownerï¼‰
     */
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = rewardToken.balanceOf(address(this));
        require(rewardToken.transfer(owner(), balance), "Transfer failed");
    }
}
```

### 7.4 å‰ç«¯ç»Ÿä¸€é¢†å–ç•Œé¢

åˆ›å»º `frontend/src/components/UnifiedRewardClaim.tsx`ï¼š

```typescript
import { useState, useEffect } from 'react'
import { useAccount, useContractRead, useContractWrite, usePrepareContractWrite } from 'wagmi'
import { CONTRIBUTOR_REWARD_ADDRESS, CONTRIBUTOR_REWARD_ABI } from '../config'

export function UnifiedRewardClaim() {
  const { address } = useAccount()
  const [rewards, setRewards] = useState({
    devAmount: 0n,
    nodeAmount: 0n,
    feeAmount: 0n,
    total: 0n,
  })

  // æŸ¥è¯¢æ€»å¥–åŠ±
  const { data: totalRewards, refetch } = useContractRead({
    address: CONTRIBUTOR_REWARD_ADDRESS,
    abi: CONTRIBUTOR_REWARD_ABI,
    functionName: 'getTotalRewards',
    args: [address || '0x0'],
    enabled: !!address,
    watch: true,
  })

  useEffect(() => {
    if (totalRewards) {
      const [devAmount, nodeAmount, feeAmount, total] = totalRewards as [bigint, bigint, bigint, bigint]
      setRewards({ devAmount, nodeAmount, feeAmount, total })
    }
  }, [totalRewards])

  // ä¸€é”®é¢†å–
  const { config } = usePrepareContractWrite({
    address: CONTRIBUTOR_REWARD_ADDRESS,
    abi: CONTRIBUTOR_REWARD_ABI,
    functionName: 'claimRewards',
    enabled: rewards.total > 0n && !!address,
  })

  const { write: claimRewards, isLoading, isSuccess } = useContractWrite({
    ...config,
    onSuccess: () => {
      refetch()
      alert('âœ… å¥–åŠ±å·²é¢†å–ï¼')
    },
  })

  if (!address) {
    return (
      <div className="card">
        <p className="text-gray-500">è¿æ¥é’±åŒ…åå¯æŸ¥çœ‹å¹¶é¢†å–å¥–åŠ±</p>
      </div>
    )
  }

  return (
    <div className="card">
      <h3 className="text-lg font-bold mb-3">æˆ‘çš„å¥–åŠ±</h3>
      
      <div className="space-y-3">
        <div className="flex justify-between">
          <span className="text-gray-600">å¼€å‘è€…ç§¯åˆ†ï¼š</span>
          <span className="font-medium">
            {(Number(rewards.devAmount) / 1e6).toFixed(2)} USDT
          </span>
        </div>

        <div className="flex justify-between">
          <span className="text-gray-600">èŠ‚ç‚¹å¥–åŠ±ï¼š</span>
          <span className="font-medium">
            {(Number(rewards.nodeAmount) / 1e6).toFixed(2)} USDT
          </span>
        </div>

        <div className="flex justify-between">
          <span className="text-gray-600">æ‰‹ç»­è´¹åˆ†æˆï¼š</span>
          <span className="font-medium">
            {(Number(rewards.feeAmount) / 1e6).toFixed(2)} USDT
          </span>
        </div>

        <div className="flex justify-between pt-2 border-t">
          <span className="text-lg font-bold">æ€»è®¡ï¼š</span>
          <span className="text-2xl font-bold text-green-600">
            {(Number(rewards.total) / 1e6).toFixed(2)} USDT
          </span>
        </div>

        <button
          onClick={() => claimRewards?.()}
          disabled={!claimRewards || isLoading || rewards.total === 0n}
          className="btn primary w-full py-4 text-lg"
          style={{ minHeight: '48px' }}
        >
          {isLoading
            ? 'é¢†å–ä¸­...'
            : rewards.total === 0n
            ? 'æš‚æ— å¥–åŠ±'
            : 'ä¸€é”®é¢†å–æ‰€æœ‰å¥–åŠ±'}
        </button>

        {isSuccess && (
          <div className="bg-green-50 border border-green-200 rounded p-3">
            <p className="text-green-800 text-sm">
              âœ… å¥–åŠ±å·²é¢†å–ï¼å·²åˆ°è´¦ {(Number(rewards.total) / 1e6).toFixed(2)} USDT
            </p>
          </div>
        )}
      </div>

      <div className="mt-4 pt-4 border-t">
        <p className="text-xs text-gray-500">
          ğŸ’¡ åŒä¸€ä¸ªé’±åŒ…å¯åŒæ—¶é¢†å–å¼€å‘è€…ç§¯åˆ†å’ŒèŠ‚ç‚¹å¥–åŠ±ï¼Œæ— éœ€å¤šé’±åŒ…ç®¡ç†
        </p>
      </div>
    </div>
  )
}
```

### 7.5 ç§¯åˆ†åˆ†é…æµç¨‹

#### ä¸Šçº¿å‰ï¼ˆSnapshotï¼‰

1. **æ”¶é›†ç»‘å®šé’±åŒ…**ï¼š
   - æ‰«æé“¾ä¸Šäº‹ä»¶ï¼ˆWalletBoundï¼‰
   - æ”¶é›†å¼€å‘è€…è´¡çŒ®ï¼ˆGitHub APIï¼‰
   - æ”¶é›†èŠ‚ç‚¹è¿è¡Œæ•°æ®ï¼ˆGossipSub å¿ƒè·³ï¼‰

2. **ç”Ÿæˆç§¯åˆ†è¡¨**ï¼š
   ```javascript
   const rewards = [
     { wallet: '0x1234...', devPoints: 100, nodePoints: 50 },
     { wallet: '0x5678...', devPoints: 200, nodePoints: 0 },
     // ...
   ]
   ```

3. **Governance ææ¡ˆ**ï¼š
   - æ‰¹å‡†å¥–åŠ±æ± ï¼ˆé¢„å­˜ USDTï¼‰
   - è°ƒç”¨ `allocatePoints` æ‰¹é‡åˆ†é…

#### ä¸Šçº¿åï¼ˆé¢†å–ï¼‰

1. **ç”¨æˆ·æ‰“å¼€å‰ç«¯**ï¼š
   - "æˆ‘çš„å¥–åŠ±"é¡µé¢æ˜¾ç¤ºæ€»å¥–åŠ±
   - ç‚¹å‡»"ä¸€é”®é¢†å–"

2. **è‡ªåŠ¨åˆ†é…æ‰‹ç»­è´¹åˆ†æˆ**ï¼š
   - Governance å®šæœŸè°ƒç”¨ `distributeFeeRewards`
   - æŒ‰èŠ‚ç‚¹è´¡çŒ®æ¯”ä¾‹åˆ†é…

### 7.6 é˜²ä½œå¼Šæœºåˆ¶

1. **ç»‘å®šéªŒè¯**ï¼š
   - éœ€é’±åŒ…ç­¾åï¼ˆ`msg.sender == wallet`ï¼‰
   - EIP-712 ç­¾åéªŒè¯ï¼ˆå¯é€‰ï¼‰

2. **èŠ‚ç‚¹ç§¯åˆ†éªŒè¯**ï¼š
   - æœ€å°è¿è¡Œæ—¶é•¿ï¼ˆ7 å¤©ï¼‰
   - è®¢å•æ’®åˆè¯æ˜
   - å¿ƒè·³éªŒè¯

3. **Governance é»‘åå•**ï¼š
   - å¯æ ‡è®°æ¶æ„åœ°å€
   - ç¦æ­¢é¢†å–å¥–åŠ±

---

## å…«ã€ç›¸å…³æ–‡æ¡£

- [ä¼˜åŒ–ä¸æ”¹è¿›æ¸…å•](./ä¼˜åŒ–ä¸æ”¹è¿›æ¸…å•.md)
- [å¿«é€Ÿä¼˜åŒ–å®ç°æŒ‡å—](./å¿«é€Ÿä¼˜åŒ–å®ç°æŒ‡å—.md)
- [è´¡çŒ®å¥–åŠ±æ¥å£](./è´¡çŒ®å¥–åŠ±æ¥å£.md)
- [æ²»ç†éƒ¨ç½²ä¸ææ¡ˆæ‰§è¡ŒæŒ‡å—](./æ²»ç†éƒ¨ç½²ä¸ææ¡ˆæ‰§è¡ŒæŒ‡å—.md)
- [è´¡çŒ®åˆ†é¢†å–æœºåˆ¶å®ç°æŒ‡å—](./è´¡çŒ®åˆ†é¢†å–æœºåˆ¶å®ç°æŒ‡å—.md)

---

*æœ¬æ–‡æ¡£æä¾›ä¸Šçº¿å¥–åŠ±åˆ†å‘æœºåˆ¶çš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼ŒåŒ…æ‹¬ç»Ÿä¸€å¥–åŠ±é¢†å–æœºåˆ¶ï¼Œä»èŠ‚ç‚¹ç»‘å®šåˆ°æ‰¹é‡å‘æ”¾ï¼Œé€‚åˆé¡¹ç›®ä¸Šçº¿æ—¶çš„æ¿€åŠ±åˆ†å‘ã€‚*
