# 治理部署与提案执行指南

按顺序完成以下步骤即可完成治理部署并创建、投票、执行一条真实提案。

---

## 前置条件

- 已安装 [Foundry](https://book.getfoundry.sh/getting-started/installation)（`forge` 可用）
- 已安装 [Go](https://go.dev/dl/)（用于 merkletool）
- `contracts/.env` 中已配置 `PRIVATE_KEY`（部署者/owner 私钥）
- 钱包有 Sepolia 测试 ETH（用于 gas）

---

## 步骤 1：运行部署脚本

```powershell
cd d:\P2P\contracts
.\scripts\deploy-governance.ps1
```

脚本会依次：
- 部署 ContributorReward（若未设置 `CONTRIBUTOR_REWARD_ADDRESS`）
- 部署 Governance 并绑定 Settlement、AMMPool、ContributorReward
- 部署 TokenRegistry、ChainConfig 并设置 `GOVERNANCE_ADDRESS`

若出现 `fork-url` 相关错误，可先设置环境变量：
```powershell
$env:SEPOLIA_RPC_URL = "https://ethereum-sepolia.publicnode.com"
```

**若 ContributorReward 已部署**（如上次只完成了 Step 0），可跳过重复部署：
```powershell
$env:CONTRIBUTOR_REWARD_ADDRESS = "0x851019107c4F3150D90f1629f6A646eBC1B1E286"
```

**若非 Settlement/AMMPool 的 owner**（出现 empty revert data），可仅绑定 ContributorReward：
```powershell
$env:SKIP_SETTLEMENT_AMM = "1"
```
Governance 仍可管理 ContributorReward、TokenRegistry、ChainConfig；Settlement/AMMPool 的 feeBps 需由 owner 手动绑定。绑定脚本：`contracts/scripts/bind-settlement-amm-to-governance.ps1`

**若链上已部署的 Settlement/AMMPool 为旧版（无 governance 支持，调用 `governance()` 或 `setGovernance` 会 revert）**，可重新部署并绑定：
```powershell
cd d:\P2P\contracts
.\scripts\redeploy-settlement-amm.ps1
```
脚本会部署新的 Settlement、AMMPool，在 Vault 上设置新 Settlement，并对新合约调用 `setGovernance`。执行完成后按终端提示更新 `frontend/src/config.ts` 与 `docs/API-接口说明.md` 中的 Settlement、AMMPool 地址。注意：新 AMM 池流动性为空，需重新添加流动性。

**必做**：将终端输出的 Governance 地址填入前端配置：
- 打开 `frontend/src/config.ts`
- 将 `GOVERNANCE_ADDRESS` 的 `'0x0000...0000'` 替换为脚本输出的地址（如 `'0xabcd...'`）
- 保存后重启前端（`npm run dev`），治理卡片会显示提案列表与操作表单

---

## 步骤 2：准备活跃地址列表

从 ContributorReward 的 `ProofSubmitted` 事件或自有数据库收集「最近 4 周有贡献」的去重地址，每行一个，保存为 `node/active-addresses.txt`。

**测试用**：可先用部署者地址作为唯一活跃地址，例如：

```
0x你的钱包地址
```

参考 `node/active-addresses.example.txt`。

---

## 步骤 3：用 merkletool 生成 root 与 proof

```bash
cd node
go run ./cmd/merkletool -list active-addresses.txt
```

记录输出的 `merkleRoot` 和 `activeCount`。

为每个需要投票的地址生成 proof：

```bash
go run ./cmd/merkletool -list active-addresses.txt -proof-for 0x<投票者地址>
```

记录输出的 proof 数组（用于 `vote` 调用）。

---

## 步骤 4：创建提案

以将 Settlement 费率改为 8 bps (0.08%) 为例：

```powershell
$rpc = "https://ethereum-sepolia.publicnode.com"
$gov = "0x..."        # 步骤 1 输出的 Governance 地址
$settlement = "0x493Da680973F6c222c89eeC02922E91F1D9404a0"   # 当前 Sepolia Settlement，见 docs/API-接口说明.md
$root = "0x..."       # 步骤 3 的 merkleRoot
$activeCount = 1      # 步骤 3 的 activeCount（单地址则为 1）

$calldata = (cast calldata "setFeeBps(uint16)" 8)
cast send $gov "createProposal(address,bytes,bytes32,uint256)" $settlement $calldata $root $activeCount --rpc-url $rpc --private-key $env:PRIVATE_KEY
```

从 `ProposalCreated` 事件中记录 `proposalId`（通常为 0）。

---

## 步骤 5：投票

使用活跃地址的私钥调用 `vote`：

```powershell
$proposalId = 0
$support = $true
$proof = "[]"   # 单地址时 proof 为空数组；多地址时填 merkletool 输出的 proof，如 "[\"0x...\",\"0x...\"]"

cast send $gov "vote(uint256,bool,bytes32[])" $proposalId $support $proof --rpc-url $rpc --private-key $env:PRIVATE_KEY
```

通过条件：`yesCount > activeCount / 2`。单地址时投 1 票赞成即可通过。

---

## 步骤 6：执行

投票期（7 天）结束后执行。**测试时可先用 `cast rpc evm_increaseTime 604800` 在本地 fork 上快进，主网/测试网需等待 7 天。**

```powershell
cast send $gov "execute(uint256)" $proposalId --rpc-url $rpc --private-key $env:PRIVATE_KEY
```

执行后，同一 (target, callData) 有 **7 天冷却期** 才能再创建相同提案。

---

## 更多提案类型

- **上币**：target = TokenRegistry，callData = `cast calldata "addToken(address)" <token地址>`
- **添加流通链**：target = ChainConfig，callData = `cast calldata "addChain(uint256)" <chainId>`

详见 [contracts/scripts/create-proposal-example.md](../contracts/scripts/create-proposal-example.md)。

---

## 前端验证（创建提案 → 投票 → 执行）

1. **创建提案**：在治理卡片「创建提案（改 Settlement 费率）」中填写 feeBps、activeCount、merkleRoot（由步骤 3 的 merkletool 得到），点击「创建提案」。
2. **投票**：在「投票」中填写提案 ID（通常为 0）、勾选赞成、proof 填 `[]`（单地址时）或 merkletool 的 `-proof-for` 输出（JSON 数组），点击「投票」。
3. **执行**：投票期（7 天）结束后，在「执行」中填写提案 ID，点击「执行」。主网/测试网需等待 7 天；本地 fork 可用 `cast rpc evm_increaseTime 604800` 快进后执行。
4. 验证：执行成功后，Settlement 的 `feeBps` 会变为提案中的值（可在区块浏览器或前端后续逻辑中确认）。
