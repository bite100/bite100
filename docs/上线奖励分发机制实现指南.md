# 上线奖励分发机制实现指南

> 节点绑定钱包 + 上线时批量空投 - 激励节点运营者和开发者

---

## 一、核心思路

**目标**：节点启动/注册时绑定钱包 → 上线前 snapshot 节点/贡献 → 上线瞬间通过合约/多签批量空投到绑定的钱包。

**价值**：
- 让节点运营者更有动力长期运行节点（上线就有即时奖励）
- 开发者得到认可和奖励
- 项目上线的一大亮点

---

## 二、节点绑定钱包（三种方式）

### 2.1 选项 A：配置文件绑定（最简单，立即可加）

**优点**：零链上成本，用户友好

**实现步骤**：

#### 步骤 1：配置文件添加

在 `node/config.yaml` 中添加：

```yaml
reward:
  wallet: "0xYourWalletAddressHere"  # 奖励接收钱包地址
  auto_register: true                 # 是否自动注册到链上
```

或在 `node/.env` 中添加：

```bash
REWARD_WALLET=0xYourWalletAddressHere
```

#### 步骤 2：Go 代码读取配置

更新 `node/internal/config/config.go`：

```go
type Config struct {
    // ... 现有配置
    Reward struct {
        Wallet      string `yaml:"wallet" env:"REWARD_WALLET"`
        AutoRegister bool   `yaml:"auto_register" env:"AUTO_REGISTER"`
    } `yaml:"reward"`
}
```

#### 步骤 3：节点启动时广播绑定消息

更新 `node/cmd/node/main.go`：

```go
package main

import (
    "fmt"
    "github.com/libp2p/go-libp2p/core/peer"
    "crypto/sha256"
)

func registerNodeWallet(nodeID peer.ID, walletAddr string) {
    // 方式1：通过 GossipSub 广播
    nodeIDHash := sha256.Sum256([]byte(nodeID.String()))
    
    message := map[string]interface{}{
        "type": "node_registration",
        "node_id": nodeID.String(),
        "node_id_hash": fmt.Sprintf("%x", nodeIDHash),
        "wallet": walletAddr,
        "timestamp": time.Now().Unix(),
    }
    
    // 广播到 GossipSub topic: "node-registration"
    // p2pNode.Publish("node-registration", json.Marshal(message))
    
    // 方式2：写到本地日志/文件，供后续 snapshot 用
    logFile := fmt.Sprintf("node-registration-%s.json", nodeID.String()[:8])
    // 写入文件...
    
    fmt.Printf("✅ 节点钱包已绑定: %s -> %s\n", nodeID.String()[:8], walletAddr)
}
```

### 2.2 选项 B：链上注册（更防作弊、可验证）

**优点**：防作弊、可验证、透明

**实现步骤**：

#### 步骤 1：创建 NodeRegistry 合约

创建 `contracts/src/NodeRegistry.sol`：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";

/**
 * @title NodeRegistry
 * @notice 节点钱包绑定注册表，用于上线奖励分发
 */
contract NodeRegistry is Ownable {
    // nodeID hash => 钱包地址
    mapping(bytes32 => address) public nodeToWallet;
    
    // 钱包地址 => nodeID hash（反向映射，用于查询）
    mapping(address => bytes32) public walletToNode;
    
    // 注册时间记录
    mapping(bytes32 => uint256) public registrationTime;
    
    event NodeRegistered(bytes32 indexed nodeId, address indexed wallet, uint256 timestamp);
    event NodeUpdated(bytes32 indexed nodeId, address indexed oldWallet, address indexed newWallet);

    /**
     * @notice 注册节点钱包绑定
     * @param nodeId 节点 ID 的 hash（libp2p peerID hash）
     * @param wallet 奖励接收钱包地址
     */
    function register(bytes32 nodeId, address wallet) external {
        require(wallet != address(0), "Invalid wallet");
        require(nodeToWallet[nodeId] == address(0), "Node already registered");
        
        // 如果钱包已绑定其他节点，不允许重复绑定
        require(walletToNode[wallet] == bytes32(0) || walletToNode[wallet] == nodeId, "Wallet already bound");
        
        nodeToWallet[nodeId] = wallet;
        walletToNode[wallet] = nodeId;
        registrationTime[nodeId] = block.timestamp;
        
        emit NodeRegistered(nodeId, wallet, block.timestamp);
    }

    /**
     * @notice 更新节点钱包（需签名验证）
     * @param nodeId 节点 ID
     * @param newWallet 新钱包地址
     * @param signature EIP-712 签名（可选，增强安全性）
     */
    function updateWallet(bytes32 nodeId, address newWallet, bytes calldata signature) external {
        require(newWallet != address(0), "Invalid wallet");
        address oldWallet = nodeToWallet[nodeId];
        require(oldWallet != address(0), "Node not registered");
        
        // 验证签名：只有原钱包或节点运营者可以更新
        // TODO: 实现 EIP-712 签名验证
        
        nodeToWallet[nodeId] = newWallet;
        walletToNode[oldWallet] = bytes32(0);
        walletToNode[newWallet] = nodeId;
        
        emit NodeUpdated(nodeId, oldWallet, newWallet);
    }

    /**
     * @notice 批量查询节点钱包（用于 snapshot）
     */
    function getRegisteredNodes(uint256 offset, uint256 limit) external view returns (
        bytes32[] memory nodeIds,
        address[] memory wallets,
        uint256[] memory timestamps
    ) {
        // 注意：此函数需要遍历，gas 消耗较高
        // 建议用事件日志离线查询，或实现索引
        // 这里提供简化版本
        revert("Use event logs for batch queries");
    }
}
```

#### 步骤 2：部署合约

```bash
cd contracts
forge script script/DeployNodeRegistry.s.sol --rpc-url $SEPOLIA_RPC --broadcast
```

#### 步骤 3：节点启动脚本注册

创建 `node/scripts/register-node.sh`：

```bash
#!/bin/bash

# 配置
NODE_ID=$(cat node/peerkey | head -1)  # 从节点配置读取
WALLET_ADDR="${REWARD_WALLET:-0xYourWalletAddress}"
REGISTRY_ADDR="0x..."  # NodeRegistry 合约地址
PRIVATE_KEY="${NODE_PRIVATE_KEY}"  # 节点运营者私钥（或使用 relayer）

# 计算 nodeID hash
NODE_ID_HASH=$(cast keccak "$NODE_ID")

# 调用合约注册
cast send --rpc-url $SEPOLIA_RPC \
  $REGISTRY_ADDR \
  "register(bytes32,address)" \
  $NODE_ID_HASH \
  $WALLET_ADDR \
  --private-key $PRIVATE_KEY

echo "✅ 节点已注册: $NODE_ID_HASH -> $WALLET_ADDR"
```

### 2.3 选项 C：前端/CLI 绑定（用户最友好）

**优点**：用户友好，无需修改节点代码

**实现步骤**：

#### 步骤 1：前端添加"节点管理"页面

创建 `frontend/src/components/NodeManagement.tsx`：

```typescript
import { useState } from 'react'
import { useAccount, useContractWrite, usePrepareContractWrite } from 'wagmi'
import { NODE_REGISTRY_ADDRESS, NODE_REGISTRY_ABI } from '../config'
import { keccak256, toUtf8Bytes } from 'ethers'

export function NodeManagement() {
  const { address } = useAccount()
  const [nodeId, setNodeId] = useState('')

  // 计算 nodeID hash
  const nodeIdHash = nodeId ? keccak256(toUtf8Bytes(nodeId)) : '0x0'

  const { config } = usePrepareContractWrite({
    address: NODE_REGISTRY_ADDRESS,
    abi: NODE_REGISTRY_ABI,
    functionName: 'register',
    args: [nodeIdHash, address || '0x0'],
    enabled: !!nodeId && !!address,
  })

  const { write, isLoading, isSuccess } = useContractWrite(config)

  return (
    <div className="card">
      <h3 className="text-lg font-bold mb-3">节点钱包绑定</h3>
      
      <div className="space-y-4">
        <div>
          <label className="block text-sm font-medium mb-1">
            节点 ID（从节点日志读取）
          </label>
          <input
            type="text"
            value={nodeId}
            onChange={(e) => setNodeId(e.target.value)}
            placeholder="12D3KooW..."
            className="input w-full"
          />
          <p className="text-xs text-gray-500 mt-1">
            节点 ID 可在节点启动日志中找到
          </p>
        </div>

        <div>
          <label className="block text-sm font-medium mb-1">
            奖励接收钱包
          </label>
          <div className="input bg-gray-100">
            {address || '请先连接钱包'}
          </div>
        </div>

        <button
          onClick={() => write?.()}
          disabled={!write || isLoading || !nodeId || !address}
          className="btn primary w-full"
        >
          {isLoading ? '注册中...' : '绑定钱包'}
        </button>

        {isSuccess && (
          <div className="bg-green-50 border border-green-200 rounded p-3">
            <p className="text-green-800 text-sm">
              ✅ 节点钱包已绑定！上线时将自动发放奖励到此钱包。
            </p>
          </div>
        )}
      </div>
    </div>
  )
}
```

#### 步骤 2：CLI 命令（可选）

创建 `node/cmd/register/main.go`：

```go
package main

import (
    "flag"
    "fmt"
    "os"
    
    "github.com/ethereum/go-ethereum/accounts/abi/bind"
    "github.com/ethereum/go-ethereum/common"
    "github.com/ethereum/go-ethereum/ethclient"
)

func main() {
    nodeID := flag.String("node-id", "", "Node ID (libp2p peerID)")
    walletAddr := flag.String("wallet", "", "Wallet address")
    registryAddr := flag.String("registry", "", "NodeRegistry contract address")
    flag.Parse()
    
    // 连接 RPC
    client, _ := ethclient.Dial(os.Getenv("RPC_URL"))
    
    // 调用合约注册
    // ... 实现合约调用逻辑
    
    fmt.Printf("✅ 节点已注册: %s -> %s\n", *nodeID, *walletAddr)
}
```

---

## 三、上线时批量发放（三种方式）

### 3.1 方式 1：Merkle Airdrop（推荐，gas 高效）

**优点**：Gas 高效，用户按需领取

**实现步骤**：

#### 步骤 1：创建 MerkleDistributor 合约

创建 `contracts/src/MerkleDistributor.sol`：

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/**
 * @title MerkleDistributor
 * @notice 基于 Merkle Tree 的奖励分发合约
 */
contract MerkleDistributor is Ownable {
    IERC20 public immutable token;
    bytes32 public merkleRoot;
    uint256 public totalAmount;
    
    mapping(address => bool) public claimed;
    
    event Claimed(address indexed account, uint256 amount);
    event MerkleRootUpdated(bytes32 indexed newRoot, uint256 totalAmount);

    constructor(address _token) Ownable(msg.sender) {
        token = IERC20(_token);
    }

    /**
     * @notice 设置 Merkle Root（仅 Owner，上线前设置）
     */
    function setMerkleRoot(bytes32 _merkleRoot, uint256 _totalAmount) external onlyOwner {
        merkleRoot = _merkleRoot;
        totalAmount = _totalAmount;
        emit MerkleRootUpdated(_merkleRoot, _totalAmount);
    }

    /**
     * @notice 领取奖励
     * @param index 在 Merkle Tree 中的索引
     * @param account 领取地址
     * @param amount 奖励金额
     * @param merkleProof Merkle 证明
     */
    function claim(
        uint256 index,
        address account,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external {
        require(!claimed[account], "Already claimed");
        
        // 验证 Merkle 证明
        bytes32 node = keccak256(abi.encodePacked(index, account, amount));
        require(
            MerkleProof.verify(merkleProof, merkleRoot, node),
            "Invalid merkle proof"
        );
        
        claimed[account] = true;
        require(token.transfer(account, amount), "Transfer failed");
        
        emit Claimed(account, amount);
    }

    /**
     * @notice 批量领取（可选，gas 优化）
     */
    function batchClaim(
        uint256[] calldata indices,
        address[] calldata accounts,
        uint256[] calldata amounts,
        bytes32[][] calldata merkleProofs
    ) external {
        require(
            indices.length == accounts.length &&
            accounts.length == amounts.length &&
            amounts.length == merkleProofs.length,
            "Length mismatch"
        );
        
        for (uint256 i = 0; i < accounts.length; i++) {
            if (!claimed[accounts[i]]) {
                bytes32 node = keccak256(abi.encodePacked(indices[i], accounts[i], amounts[i]));
                require(
                    MerkleProof.verify(merkleProofs[i], merkleRoot, node),
                    "Invalid merkle proof"
                );
                claimed[accounts[i]] = true;
                require(token.transfer(accounts[i], amounts[i]), "Transfer failed");
                emit Claimed(accounts[i], amounts[i]);
            }
        }
    }

    /**
     * @notice 紧急提取（仅 Owner）
     */
    function emergencyWithdraw() external onlyOwner {
        uint256 balance = token.balanceOf(address(this));
        require(token.transfer(owner(), balance), "Transfer failed");
    }
}
```

#### 步骤 2：生成 Merkle Tree

创建 `scripts/generate-merkle-tree.js`：

```javascript
const { MerkleTree } = require('merkletreejs')
const keccak256 = require('keccak256')
const fs = require('fs')

// 奖励列表（从 snapshot 生成）
const rewards = [
  { address: '0x1234...', amount: '1000000000000000000' }, // 1 USDT (18 decimals)
  { address: '0x5678...', amount: '2000000000000000000' }, // 2 USDT
  // ... 更多地址
]

// 生成 Merkle Tree
const leaves = rewards.map((r, index) =>
  keccak256(
    Buffer.concat([
      Buffer.from(index.toString().padStart(64, '0'), 'hex'),
      Buffer.from(r.address.slice(2), 'hex'),
      Buffer.from(BigInt(r.amount).toString(16).padStart(64, '0'), 'hex'),
    ])
  )
)

const tree = new MerkleTree(leaves, keccak256, { sortPairs: true })
const root = tree.getRoot()

// 生成证明文件
const proofs = rewards.map((r, index) => {
  const leaf = leaves[index]
  const proof = tree.getProof(leaf)
  return {
    index,
    address: r.address,
    amount: r.amount,
    proof: proof.map(p => '0x' + p.data.toString('hex')),
  }
})

// 保存结果
fs.writeFileSync('merkle-tree.json', JSON.stringify({
  root: '0x' + root.toString('hex'),
  totalAmount: rewards.reduce((sum, r) => sum + BigInt(r.amount), 0n).toString(),
  proofs,
}, null, 2))

console.log('✅ Merkle Tree 已生成')
console.log('Root:', '0x' + root.toString('hex'))
console.log('Total amount:', rewards.reduce((sum, r) => sum + BigInt(r.amount), 0n).toString())
```

#### 步骤 3：前端领取界面

创建 `frontend/src/components/ClaimAirdrop.tsx`：

```typescript
import { useState, useEffect } from 'react'
import { useAccount, useContractWrite, usePrepareContractWrite } from 'wagmi'
import { MERKLE_DISTRIBUTOR_ADDRESS, MERKLE_DISTRIBUTOR_ABI } from '../config'

export function ClaimAirdrop() {
  const { address } = useAccount()
  const [proof, setProof] = useState<any>(null)
  const [amount, setAmount] = useState<bigint>(0n)

  // 从 API 或文件加载用户的 Merkle 证明
  useEffect(() => {
    if (!address) return
    
    fetch(`/api/merkle-proof/${address}`)
      .then(res => res.json())
      .then(data => {
        setProof(data.proof)
        setAmount(BigInt(data.amount))
      })
  }, [address])

  const { config } = usePrepareContractWrite({
    address: MERKLE_DISTRIBUTOR_ADDRESS,
    abi: MERKLE_DISTRIBUTOR_ABI,
    functionName: 'claim',
    args: proof ? [
      proof.index,
      address,
      amount,
      proof.proof,
    ] : undefined,
    enabled: !!proof && !!address,
  })

  const { write, isLoading, isSuccess } = useContractWrite(config)

  if (!address) {
    return <div className="card">请先连接钱包</div>
  }

  if (!proof) {
    return <div className="card">查询中...</div>
  }

  return (
    <div className="card">
      <h3 className="text-lg font-bold mb-3">领取上线奖励</h3>
      
      <div className="space-y-4">
        <div className="flex justify-between">
          <span>可领取奖励：</span>
          <span className="text-2xl font-bold text-green-600">
            {(Number(amount) / 1e18).toFixed(2)} USDT
          </span>
        </div>

        <button
          onClick={() => write?.()}
          disabled={!write || isLoading}
          className="btn primary w-full py-4"
        >
          {isLoading ? '领取中...' : '立即领取'}
        </button>

        {isSuccess && (
          <div className="bg-green-50 border border-green-200 rounded p-3">
            <p className="text-green-800">✅ 奖励已领取！</p>
          </div>
        )}
      </div>
    </div>
  )
}
```

### 3.2 方式 2：批量 Multisig 推送（简单直接）

**优点**：简单直接，无需用户操作

**实现步骤**：

#### 步骤 1：准备奖励列表

创建 `scripts/prepare-airdrop-list.js`：

```javascript
// 从 snapshot 生成奖励列表
const rewards = [
  { address: '0x1234...', amount: '1000000000000000000' },
  { address: '0x5678...', amount: '2000000000000000000' },
  // ...
]

// 保存为 JSON
fs.writeFileSync('airdrop-list.json', JSON.stringify(rewards, null, 2))
```

#### 步骤 2：批量转账脚本

创建 `scripts/batch-transfer.js`：

```javascript
const { ethers } = require('ethers')
const rewards = require('./airdrop-list.json')

async function batchTransfer() {
  const provider = new ethers.JsonRpcProvider(process.env.RPC_URL)
  const wallet = new ethers.Wallet(process.env.PRIVATE_KEY, provider)
  const token = new ethers.Contract(USDT_ADDRESS, ERC20_ABI, wallet)

  for (const reward of rewards) {
    try {
      const tx = await token.transfer(reward.address, reward.amount)
      console.log(`✅ 已转账到 ${reward.address}: ${tx.hash}`)
      await tx.wait()
    } catch (err) {
      console.error(`❌ 转账失败 ${reward.address}:`, err)
    }
  }
}

batchTransfer()
```

#### 步骤 3：使用 Gnosis Safe Multisig

1. 创建 Gnosis Safe 多签钱包
2. 预存 USDT 到多签钱包
3. 使用 Gnosis Safe API 批量创建交易
4. 多签批准后批量执行

### 3.3 方式 3：自动从 FeeDistributor 拉取

**优点**：可持续，无需预存资金

**实现步骤**：

在 `FeeDistributor` 合约中添加上线奖励逻辑：

```solidity
mapping(address => uint256) public launchRewards;  // 上线奖励额度
mapping(address => bool) public launchRewardClaimed;  // 是否已领取

function claimLaunchReward() external {
    require(!launchRewardClaimed[msg.sender], "Already claimed");
    require(launchRewards[msg.sender] > 0, "No reward");
    
    uint256 amount = launchRewards[msg.sender];
    launchRewards[msg.sender] = 0;
    launchRewardClaimed[msg.sender] = true;
    
    // 从手续费池中提取
    require(token.transfer(msg.sender, amount), "Transfer failed");
    emit LaunchRewardClaimed(msg.sender, amount);
}
```

---

## 四、积分规则细化

### 4.1 开发者积分

**来源**：
- GitHub PR/commits（自动统计）
- 文档贡献（手动审核）
- 测试贡献（手动审核）

**规则**：
- 1 积分 = 1 USDT
- 上线前累计
- 最小贡献：1 PR 或 100 行代码

### 4.2 节点积分

**来源**：
- 运行时长（每天在线 1 积分）
- 撮合订单量（每 100 笔订单 1 积分）
- 网络贡献（中继、存储等）

**规则**：
- 最小运行时长：7 天
- 防刷：需心跳验证、最小撮合量

### 4.3 总池分配

**建议分配**：
- 50% 给开发者（上线时发放）
- 30% 给节点运营者（上线时发放）
- 20% 预留（从手续费长期分成）

---

## 五、实施步骤（快速 Roadmap）

### 阶段 1：节点绑定（1 周）

1. ✅ 决定绑定方式（推荐选项 A + B 结合）
2. ✅ 创建 NodeRegistry 合约
3. ✅ 部署到 Sepolia 测试网
4. ✅ 修改 node 启动脚本/Go 代码：支持绑定 + 注册
5. ✅ 前端加"绑定钱包"按钮（可选）

### 阶段 2：Snapshot 准备（1 周）

1. ✅ 写 snapshot 脚本：
   - 扫描链上事件（NodeRegistered）
   - 收集开发者贡献（GitHub API）
   - 生成积分表
2. ✅ 生成 Merkle Tree（如果用方式 1）
3. ✅ 审核和确认奖励列表

### 阶段 3：上线发放（上线时）

1. ✅ Governance 提案：批准上线 + 奖励池
2. ✅ 设置 Merkle Root（如果用方式 1）
3. ✅ 批量转账（如果用方式 2）
4. ✅ 用户领取界面上线

---

## 六、相关文档

- [优化与改进清单](./优化与改进清单.md)
- [快速优化实现指南](./快速优化实现指南.md)
- [贡献奖励接口](./贡献奖励接口.md)
- [治理部署与提案执行指南](./治理部署与提案执行指南.md)

---

*本文档提供上线奖励分发机制的完整实现方案，从节点绑定到批量发放，适合项目上线时的激励分发。*
