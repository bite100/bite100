# P2P 去中心化交易所 - 技术架构说明

> 版本：v0.1  
> 更新日期：2025-02-07  
> 关联文档：[概念设计文档](./概念设计文档.md)

---

## 一、架构概览

### 1.1 分层架构

```
┌─────────────────────────────────────────────────────────────────────────┐
│  Layer 4: 应用层 (Application Layer)                                     │
│  Web DApp | 移动端 | CLI | SDK                                          │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
┌─────────────────────────────────────────────────────────────────────────┐
│  Layer 3: 服务层 (Service Layer)                                         │
│  订单管理 | 撮合引擎 | 贡献统计 | 数据同步                                │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
┌─────────────────────────────────────────────────────────────────────────┐
│  Layer 2: P2P 网络层 (Network Layer)                                     │
│  libp2p | Gossip | DHT | 节点发现 | 消息路由                             │
└─────────────────────────────────────────────────────────────────────────┘
                                    │
┌─────────────────────────────────────────────────────────────────────────┐
│  Layer 1: 区块链层 (Blockchain Layer)                                    │
│  智能合约 | 资产托管 | 结算 | 激励分配                                   │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 核心设计原则

| 原则 | 说明 |
|------|------|
| **链下撮合，链上结算** | 订单匹配在 P2P 节点完成，资产清算在链上执行 |
| **无状态服务** | 节点可随时加入/退出，数据从网络同步 |
| **贡献可验证** | 所有贡献数据可追溯，链上可审计 |
| **数据保留两年** | 交易数据仅保留近两年，超期自动清理 |
| **未来支持手机端** | 首期以 Web 为主，后续提供 iOS / Android 客户端 |

---

## 二、区块链层

### 2.1 技术选型

| 组件 | 推荐方案 | 备选 |
|------|---------|------|
| 公链 | Ethereum / Arbitrum / Base | Solana, 自建 L2 |
| 合约语言 | Solidity 0.8+ | Vyper |
| 开发框架 | Foundry / Hardhat | - |
| 跨链 | LayerZero / Axelar | Bridge 自建 |

### 2.2 智能合约模块

```
contracts/
├── Vault.sol              # 资产托管保险库
├── OrderBook.sol          # 订单簿状态锚定（校验用）
├── Settlement.sol         # 交易结算
├── FeeDistributor.sol     # 手续费分配
├── ContributorReward.sol  # 贡献者奖励发放
└── TokenPair.sol          # 交易对管理
```

### 2.3 合约职责

| 合约 | 职责 | 核心方法 |
|------|------|---------|
| **Vault** | 托管用户资产，划转结算 | `deposit`, `withdraw`, `transfer` |
| **Settlement** | 执行成交后的资产划转 | `settleTrade`, `batchSettle` |
| **FeeDistributor** | 按比例分配手续费 | `distribute`, `claim` |
| **ContributorReward** | 发放节点贡献奖励 | `submitProof`, `claimReward` |

### 2.4 结算流程

```
1. 用户 approve → Vault
2. 用户 deposit 资产至 Vault
3. 链下撮合产生成交信息
4. 提交成交证明至 Settlement 合约
5. 合约验证后执行资产划转
6. 手续费转入 FeeDistributor
7. 定期触发分配（贡献者 claim）
```

---

## 三、P2P 网络层

### 3.1 技术选型

| 组件 | 推荐方案 | 说明 |
|------|---------|------|
| P2P 协议 | libp2p | 模块化、多传输、节点发现 |
| 传输层 | TCP、QUIC、WebRTC | 穿透 NAT，支持浏览器 |
| 消息广播 | GossipSub | 低延迟、可扩展 |
| 分布式存储 | IPFS / 自定义 DHT | 订单簿、历史数据 |
| 节点发现 | Bootstrap + mDNS | 初始连接、局域网发现 |

### 3.2 网络拓扑

```
                    ┌─────────────┐
                    │   Bootstrap │
                    │   Nodes     │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐        ┌────▼────┐        ┌────▼────┐
   │ 中继节点 │◄──────►│ 中继节点 │◄──────►│ 中继节点 │
   └────┬────┘        └────┬────┘        └────┬────┘
        │                  │                  │
   ┌────▼────┐        ┌────▼────┐        ┌────▼────┐
   │ 撮合节点 │        │ 存储节点 │        │ 普通节点 │
   └─────────┘        └─────────┘        └─────────┘
```

### 3.3 消息类型

| Topic | 消息类型 | 说明 |
|-------|---------|------|
| `/order/new` | Order | 新订单广播 |
| `/order/cancel` | CancelRequest | 撤单请求 |
| `/trade/executed` | Trade | 成交确认 |
| `/sync/orderbook` | OrderbookDelta | 订单簿增量同步 |
| `/sync/trades` | TradeBatch | 历史成交批量同步 |
| `/contrib/proof` | ContributionProof | 贡献证明（周期上报） |

### 3.4 节点发现与连接

```
1. 启动时连接 Bootstrap 节点列表（硬编码/配置）
2. 通过 DHT 发现更多对等节点
3. GossipSub 订阅相关 Topic，加入 mesh
4. 维持最小连接数（如 8-32），动态调整
5. 支持 NAT 穿透（libp2p relay / AutoNAT）
```

---

## 四、服务层

### 4.1 撮合引擎

- **模式**：中央限价订单簿（CLOB）
- **托管位置**：链下内存，定期快照锚定
- **撮合算法**：价格优先、时间优先（Price-Time Priority）

```
订单簿结构：
  Buy  Side: [[price, quantity], ...]  // 降序
  Sell Side: [[price, quantity], ...]  // 升序
  
撮合逻辑：
  while (新订单剩余量 > 0 && 对手盘有挂单 && 价格可成交):
      match(新订单, 对手盘最优订单)
      生成 Trade 记录
      更新订单簿
```

### 4.2 存储节点数据模型

#### 4.2.1 订单

```json
{
  "orderId": "0x...",
  "trader": "0x...",
  "pair": "ETH/USDT",
  "side": "buy",
  "price": "2000.00",
  "amount": "1.5",
  "filled": "0",
  "status": "open",
  "createdAt": 1707292800,
  "expiresAt": 1707300000
}
```

#### 4.2.2 成交

```json
{
  "tradeId": "0x...",
  "pair": "ETH/USDT",
  "takerOrderId": "0x...",
  "makerOrderId": "0x...",
  "price": "2000.00",
  "amount": "0.5",
  "fee": "0.003",
  "timestamp": 1707292850
}
```

#### 4.2.3 数据保留策略

| 数据类型 | 保留期限 | 清理策略 |
|---------|---------|---------|
| 订单簿快照 | 滚动窗口 | 每 N 小时持久化，保留近两年 |
| 历史成交 | 2 年 | 按 `timestamp` 过滤，超期删除 |
| 订单变更日志 | 2 年 | 按 `createdAt` 过滤，超期删除 |

**实现要点**：
- 存储节点定时任务：每日扫描，删除 `timestamp < now - 2years` 的记录
- 同步协议：请求历史数据时携带时间范围参数 `since`, `until`
- 区块链：结算证明永久保留，链上不存储完整订单/成交明细

### 4.3 贡献度量

| 指标 | 采集方式 | 周期 |
|------|---------|------|
| 在线时长 | 心跳 + 抽查 | 每分钟 |
| 撮合成交量 | 撮合节点上报 | 每笔 |
| 存储容量 | 存储节点自报 + 抽查 | 每小时 |
| 带宽/转发量 | 中继节点统计 | 每 10 分钟 |

贡献证明结构：

```json
{
  "nodeId": "0x...",
  "period": "2025-02-01_2025-02-07",
  "metrics": {
    "uptime": 0.95,
    "tradesMatched": 1200,
    "storageGB": 50,
    "bytesRelayed": 1073741824
  },
  "signature": "0x..."
}
```

---

## 五、应用层

### 5.1 客户端类型

| 类型 | 技术栈 | 用途 |
|------|--------|------|
| Web DApp | React + ethers.js / wagmi | 浏览器交易（首期） |
| 移动端 | React Native / Flutter | 手机端交易（未来支持） |
| CLI | Node.js / Go | 自动化、脚本 |
| SDK | TypeScript / Rust | 第三方集成 |

### 5.2 用户交互流程

```
1. 连接钱包（MetaMask / WalletConnect）
2. 选择 P2P 节点（或自动分配）
3. 连接节点 WebSocket / libp2p
4. 下单 → 节点广播 → 撮合
5. 成交后链上结算
6. 前端轮询/订阅获取最新状态
```

### 5.3 节点软件

- **形态**：桌面应用 / 后台进程 / Docker
- **平台**：Windows / macOS / Linux
- **资源**：建议 4GB+ 内存，50GB+ 磁盘，稳定带宽
- **配置**：节点类型（撮合/存储/中继）、Bootstrap 列表、链 RPC

---

## 六、数据流详解

### 6.1 下单流程

```
Client                   中继节点                撮合节点              存储节点
   │                        │                      │                      │
   │──── Order ────────────►│                      │                      │
   │                        │──── Gossip ─────────►│                      │
   │                        │                      │── 撮合 ─────────────►│
   │                        │                      │◄── 更新订单簿 ────────│
   │                        │◄──── Trade ─────────│                      │
   │                        │──── Gossip ─────────►│                      │
   │◄──── TradeConfirm ─────│                      │                      │
   │                        │                      │                      │
   │========= 链上结算（Settlement 合约）==========│                      │
```

### 6.2 数据同步流程

```
存储节点 A                    存储节点 B
     │                             │
     │──── 请求 trades since T1 ───►│
     │◄──── TradeBatch ────────────│
     │                             │
     │  校验：timestamp 在 2 年内    │
     │  入库，超期数据不请求         │
```

---

## 七、安全架构

### 7.1 智能合约安全

- 使用 OpenZeppelin 标准库
- 多签/时间锁管理关键参数
- 第三方安全审计
- 形式化验证（关键路径）

### 7.2 节点安全

| 威胁 | 防护措施 |
|------|---------|
| Sybil 攻击 | 质押入网、信誉累积 |
| 恶意订单 | 订单签名验证、反垃圾规则 |
| 数据篡改 | 默克尔证明、链上校验 |
| DoS | 限流、黑名单、质押罚没 |

### 7.3 通信安全

- 节点间 TLS/mTLS
- 消息签名验证（secp256k1 / ed25519）
- 敏感数据加密存储

---

## 八、部署与运维

### 8.1 节点部署

```
推荐配置：
  撮合节点：8核 CPU, 16GB RAM, 100GB SSD, 100Mbps+
  存储节点：4核 CPU, 8GB RAM, 500GB+ SSD, 50Mbps+
  中继节点：2核 CPU, 4GB RAM, 50GB SSD, 200Mbps+
```

### 8.2 监控指标

- 节点在线率、延迟
- 撮合吞吐量（TPS）
- 存储使用率、剩余容量
- 贡献证明提交成功率

### 8.3 灾难恢复

- 订单簿：多节点冗余，定期快照
- 链上：依赖公链共识与备份
- 节点：无状态设计，重启即可从网络同步

---

## 九、技术栈汇总

| 层级 | 技术 | 用途 |
|------|------|------|
| 区块链 | Solidity, Foundry | 智能合约 |
| P2P | libp2p, GossipSub | 节点通信 |
| 存储 | LevelDB / RocksDB, IPFS | 链下数据 |
| 后端 | Go / Rust | 节点核心 |
| 前端 | React, ethers.js | Web DApp |
| 移动 | React Native | 移动端 |

---

## 十、附录

### 10.1 数据保留实现示例

```python
# 伪代码：存储节点清理超期数据
RETENTION_YEARS = 2

def cleanup_old_trades():
    cutoff = now() - timedelta(years=RETENTION_YEARS)
    db.execute("DELETE FROM trades WHERE timestamp < ?", cutoff)

def sync_trades(since, until):
    max_age = now() - timedelta(years=RETENTION_YEARS)
    if since < max_age:
        since = max_age  # 不请求超期数据
    return db.query("SELECT * FROM trades WHERE timestamp BETWEEN ? AND ?", since, until)
```

### 10.2 参考实现

- [go-libp2p](https://github.com/libp2p/go-libp2p)
- [Foundry](https://github.com/foundry-rs/foundry)
- [dYdX v4 架构](https://docs.dydx.exchange/)

---

*本文档为技术架构初稿，具体实现细节随开发迭代更新。*
