# 流动性贡献分实现指南

> 版本：v1.0  
> 更新日期：2025-02-08

---

## 一、概述

本文档说明如何实现和使用流动性贡献分功能。节点通过向 AMM 池注入流动性可以获得贡献分，从而获得更多奖励。

---

## 二、实现方案

### 2.1 合约修改

#### AMMPool 合约

**新增功能**：
- 记录流动性提供者信息
- 触发流动性贡献分更新事件
- 支持节点移除自己的流动性

**关键修改**：
```solidity
// 记录流动性提供者
mapping(address => LiquidityProvider) public liquidityProviders;

// 事件：流动性贡献分更新
event LiquidityScoreUpdated(address indexed provider, uint256 liquidityAmount);
```

#### ContributorReward 合约

**新增功能**：
- `submitLiquidityProof()`：提交流动性贡献证明
- `_computeLiquidityScore()`：计算流动性贡献分
- 支持 `nodeType=3`（流动性提供者）

**权重更新**：
- 撮合：40%
- 存储：25%
- **流动性：20%（新增）**
- 中继：15%

### 2.2 工作流程

#### 方式一：自动更新（推荐）

1. **节点注入流动性**：
   ```solidity
   ammPool.addLiquidity(amount0, amount1);
   ```

2. **合约记录并触发事件**：
   - 记录流动性提供者信息
   - 触发 `LiquidityScoreUpdated` 事件

3. **链下监听并更新贡献分**：
   - 监听事件
   - 调用 `ContributorReward.submitLiquidityProof()` 更新贡献分

#### 方式二：手动提交

1. **节点注入流动性**
2. **节点手动提交证明**：
   ```solidity
   contributorReward.submitLiquidityProof(period, liquidityAmount, signature);
   ```

---

## 三、使用示例

### 3.1 节点注入流动性

```solidity
// 1. 授权代币
IERC20(token0).approve(ammPoolAddress, amount0);
IERC20(token1).approve(ammPoolAddress, amount1);

// 2. 注入流动性
AMMPool(ammPoolAddress).addLiquidity(amount0, amount1);

// 3. 查询流动性数量
uint256 liquidity = AMMPool(ammPoolAddress).getLiquidityAmount(nodeAddress);
```

### 3.2 提交流动性贡献证明

```solidity
// 1. 准备签名
bytes32 digest = keccak256(abi.encodePacked(period, liquidityAmount, uint8(3)));
bytes memory signature = sign(digest, privateKey);

// 2. 提交证明
ContributorReward(contributorRewardAddress).submitLiquidityProof(
    period,
    liquidityAmount,
    signature
);
```

### 3.3 查询贡献分

```solidity
uint256 score = ContributorReward(contributorRewardAddress).getContributionScore(
    period,
    nodeAddress
);
```

---

## 四、贡献分计算

### 4.1 计算公式

```
liquidityScore = (1e18 + min(liquidityAmount / CAP_LIQUIDITY, 1e18)) * 20 / 100
```

**参数**：
- `liquidityAmount`：流动性数量（以稳定币计价）
- `CAP_LIQUIDITY`：100,000 USDC（上限）
- 权重：20%

### 4.2 示例

| 流动性数量 | 贡献分 |
|-----------|--------|
| 0 USDC | 0 |
| 10,000 USDC | 2.4e18 |
| 50,000 USDC | 12e18 |
| 100,000+ USDC | 24e18（上限） |

---

## 五、前端集成

### 5.1 显示流动性贡献分

```typescript
// 查询流动性数量
const liquidity = await ammPool.getLiquidityAmount(nodeAddress);

// 查询贡献分
const score = await contributorReward.getContributionScore(period, nodeAddress);
```

### 5.2 流动性注入界面

在现有的"添加流动性"界面添加提示：
- "注入流动性可获得贡献分"
- 显示当前流动性数量
- 显示预计贡献分

---

## 六、部署步骤

### 6.1 更新合约

1. **更新 AMMPool**：
   - 添加流动性提供者记录
   - 添加贡献分更新事件

2. **更新 ContributorReward**：
   - 添加流动性贡献分计算
   - 添加 `submitLiquidityProof` 接口

### 6.2 部署到测试网

```powershell
cd contracts
forge script script/Deploy.s.sol --rpc-url $SEPOLIA_RPC --broadcast
```

### 6.3 配置

```solidity
// 设置 ContributorReward 地址
ammPool.setContributorReward(contributorRewardAddress);
```

---

## 七、测试

### 7.1 单元测试

```solidity
function test_AddLiquidity_RecordsProvider() public {
    // 注入流动性
    ammPool.addLiquidity(1000e18, 1000e18);
    
    // 验证记录
    LiquidityProvider memory p = ammPool.liquidityProviders(user);
    assertEq(p.currentLiquidity0, 1000e18);
}

function test_SubmitLiquidityProof_UpdatesScore() public {
    // 提交证明
    contributorReward.submitLiquidityProof(period, 10000e18, signature);
    
    // 验证贡献分
    uint256 score = contributorReward.getContributionScore(period, user);
    assertGt(score, 0);
}
```

### 7.2 集成测试

1. 节点注入流动性
2. 监听事件并更新贡献分
3. 验证贡献分正确
4. 节点提取流动性
5. 验证贡献分减少

---

## 八、注意事项

### 8.1 流动性计算

- **简化处理**：使用 Token0 数量作为流动性数量
- **实际应用**：应根据价格计算等值稳定币数量

### 8.2 贡献分更新

- **自动更新**：通过事件监听自动更新（推荐）
- **手动提交**：节点可以手动提交证明

### 8.3 提取限制

- **当前实现**：节点可以随时提取流动性
- **建议**：添加锁定时间，防止刷分

---

## 九、相关文档

- [流动性贡献分设计](./流动性贡献分设计.md)
- [贡献奖励接口](./贡献奖励接口.md)
- [AMM 池设计](./概念设计文档.md)

---

*本文档说明流动性贡献分的实现和使用方法。*
