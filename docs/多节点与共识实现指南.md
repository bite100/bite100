# 多节点与共识实现指南

> 版本：v1.0  
> 更新日期：2025-02-08

---

## 一、概述

本文档说明如何实现和使用多节点撮合与共识功能。当前已实现**方案 B（分片按交易对）**的基础框架。

---

## 二、方案 B：分片按交易对

### 2.1 已实现组件

- ✅ **路由模块** (`node/internal/match/router.go`)
  - 节点注册与发现
  - 订单路由选择
  - 负载均衡

- ✅ **注册表** (`node/internal/match/registry.go`)
  - 节点注册消息广播
  - 注册消息处理
  - 定期更新

### 2.2 集成步骤

#### 步骤 1：初始化路由和注册表

在节点启动时（`cmd/node/main.go` 或类似位置）：

```go
import (
    "github.com/P2P-P2P/p2p/node/internal/match"
)

// 获取本地 PeerID
localPeerID := host.ID().String()

// 创建撮合引擎
engine := match.NewEngine(pairTokens)

// 创建路由
router := match.NewRouter(localPeerID, engine)

// 创建注册表（需要配置中的交易对列表）
localPairs := []string{"TKA/TKB", "TKC/TKD"} // 从配置读取
registry := match.NewRegistry(router, localPeerID, localPairs, publishFunc)

// 启动注册表（定期广播）
registry.Start()
```

#### 步骤 2：订阅节点注册消息

在 `sync.OrderSubscriber` 或类似位置添加：

```go
// 订阅节点注册主题
topic, err := pubsub.Join("/p2p-exchange/match/register")
if err != nil {
    return err
}

sub, err := topic.Subscribe()
if err != nil {
    return err
}

go func() {
    defer sub.Cancel()
    for {
        msg, err := sub.Next(ctx)
        if err != nil {
            return
        }
        // 处理注册消息
        registry.HandleRegistration(msg.Data)
    }
}()
```

#### 步骤 3：路由订单

在处理新订单时（`api/server.go` 或 `sync.OrderSubscriber`）：

```go
// 检查是否需要路由
needForward, targetPeerID, err := router.RouteOrder(order)
if err != nil {
    log.Printf("[router] 路由失败: %v", err)
    return err
}

if needForward {
    // 转发到目标节点
    log.Printf("[router] 转发订单到节点 %s", targetPeerID)
    if err := forwardOrderToNode(targetPeerID, order); err != nil {
        log.Printf("[router] 转发失败: %v", err)
        // 降级：本地处理
        engine.AddOrder(order)
        trades := engine.Match(order)
        // ... 处理成交
    }
} else {
    // 本地处理
    engine.AddOrder(order)
    trades := engine.Match(order)
    // ... 处理成交
}
```

#### 步骤 4：实现订单转发

需要实现 `forwardOrderToNode` 函数：

```go
func forwardOrderToNode(peerID string, order *storage.Order) error {
    // 方法 1：使用 Gossip 主题（推荐）
    // 创建专用主题：/p2p-exchange/match/order/{pair}
    topic := fmt.Sprintf("/p2p-exchange/match/order/%s", order.Pair)
    data, _ := json.Marshal(order)
    return publish(topic, data)
    
    // 方法 2：使用直接 P2P 消息
    // stream, err := host.NewStream(ctx, peerID, protocolID)
    // ...
}
```

#### 步骤 5：定期清理过期节点

在节点主循环中：

```go
// 每 5 分钟清理一次
ticker := time.NewTicker(5 * time.Minute)
defer ticker.Stop()
for range ticker.C {
    router.CleanupStaleNodes()
}
```

### 2.3 配置

在 `config.yaml` 中添加：

```yaml
match:
  mode: "sharding"  # sharding | single | consensus
  pairs:
    - "TKA/TKB"
    - "TKC/TKD"
  router:
    enable: true
    refresh_interval: 30s  # 注册信息刷新间隔
    cleanup_interval: 5m  # 过期节点清理间隔
```

### 2.4 测试

#### 测试节点注册

1. 启动两个节点，配置不同的交易对
2. 观察日志，确认注册消息广播和接收
3. 检查路由表：`router.GetAllNodes()`

#### 测试订单路由

1. 向节点 A 发送订单（交易对由节点 B 负责）
2. 确认订单被转发到节点 B
3. 确认节点 B 处理订单并广播成交

---

## 三、方案 C：多节点共识（待实现）

### 3.1 计划实现

- ⏳ BFT 共识协议
- ⏳ Leader 选举
- ⏳ 订单簿同步
- ⏳ 提案与投票

### 3.2 实现优先级

**优先级：中**  
**原因**：复杂度高，适合高安全需求场景

**建议**：先完成方案 B 的完整实现和测试，再考虑方案 C。

---

## 四、故障排查

### 4.1 节点未注册

**症状**：路由表为空，订单无法路由

**排查**：
1. 检查 Gossip 连接是否正常
2. 检查注册主题是否订阅
3. 检查 `publish` 函数是否正常工作

### 4.2 订单未转发

**症状**：订单在本地处理，但应该转发

**排查**：
1. 检查路由表：`router.GetAllNodes()`
2. 检查交易对映射：`router.SelectNode(pair)`
3. 检查节点是否在线（`UpdatedAt` 是否在 60 秒内）

### 4.3 节点负载不均衡

**症状**：某些节点负载过高

**排查**：
1. 检查 `Capacity` 更新是否及时
2. 检查负载均衡算法是否正确
3. 考虑调整路由策略

---

## 五、性能优化

### 5.1 路由表优化

- 使用更高效的数据结构（如跳表）
- 缓存常用交易对的路由结果

### 5.2 转发优化

- 批量转发订单
- 使用更高效的序列化格式（如 Protobuf）

### 5.3 负载均衡优化

- 考虑节点地理位置
- 考虑网络延迟
- 动态调整权重

---

## 六、相关文档

- [多节点与共识设计](./多节点与共识设计.md)
- [Phase3-设计文档](./Phase3-设计文档.md)
- [节点部署](./节点部署.md)

---

*本文档说明多节点撮合的实现和使用方法，建议先完成方案 B 的完整实现和测试。*
